{"meta":{"title":"kevinyangI","subtitle":null,"description":"Someone knock at the door.","author":"kevinyangI","url":"https://kevinyangI.github.io"},"pages":[{"title":"","date":"2018-07-23T02:01:23.699Z","updated":"2018-01-25T14:41:06.000Z","comments":true,"path":"404.html","permalink":"https://kevinyangI.github.io/404.html","excerpt":"","text":"404 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#fff;margin-top:40px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=4; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num"},{"title":"","date":"2018-09-23T12:38:08.000Z","updated":"2018-09-23T12:49:13.678Z","comments":true,"path":"about/index.html","permalink":"https://kevinyangI.github.io/about/index.html","excerpt":"","text":"Welcome to my blog! My Name is kevin, I am a software engineer studying at the University of Science and Technology of China. About Me | 关于我你们好，我叫 kevin，这是我的技术博客。 我崇尚 Geek 精神与开源文化，喜欢简洁、优美、模块化的代码。爱折腾，折腾系统，折腾软件，折腾语言，折腾框架……生命不息，折腾不止。 平时喜欢逛技术论坛，听音乐。没事打打球，看看电影，聚个餐，一个很普通的移动应用开发者。 感谢计算机给我们提供了一个完美的试验场，这里没有太多的约束，就像我的世界一样，是一片自由的乌托邦之地。在这里，我们可以让想象力自由驰骋，让计算机完成我们想到的事。我认为，开发实现自己设计的软件是能让我想到最兴奋的事情了。 如果你有任何问题，请给我发送邮件：&#107;&#101;&#118;&#x69;&#x6e;&#x2e;&#x79;&#97;&#x6e;&#103;&#x2e;&#x78;&#x79;&#122;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;"},{"title":"Archives","date":"2016-08-16T07:00:24.000Z","updated":"2018-01-25T14:41:06.000Z","comments":true,"path":"archives/index.html","permalink":"https://kevinyangI.github.io/archives/index.html","excerpt":"","text":""},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2018-01-25T14:41:06.000Z","comments":false,"path":"categories/index.html","permalink":"https://kevinyangI.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2018-01-25T14:41:06.000Z","comments":true,"path":"tags/index.html","permalink":"https://kevinyangI.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2019 新的开始","slug":"2019 新的开始","date":"2019-02-09T16:00:00.000Z","updated":"2019-03-04T13:44:50.166Z","comments":true,"path":"2019/02/10/2019 新的开始/","link":"","permalink":"https://kevinyangI.github.io/kevinyangI.github.io/2019/02/10/2019 新的开始/","excerpt":"","text":"## 记录生活长沙行 酒酣彻夜谈述往事历历在目 感触颇深…-2018 迷茫 放任2019-… 拒绝 提问 慎独 自律 新知 拒绝我们从小就被教育要待人以礼，当别人提出请求、邀请时，哪怕不情愿也不会立即回绝，权衡、犹豫、纠结了半天，最后还是答应了，且不说这个过程给对方造成不悦，而且还消磨了自己的时间，答应之后你得去做吧，继续消耗。别当「老好人」，这个词绝对会成为你取得进步的羁绊，我们总是在别人身上花很多时间，一边又抱怨自己效率低下，能怪谁？我们不想拒绝的原因无非是：1、怕损坏关系。2、怕失去机会，如果还有第三点，就是无缘由地想让自己变得有亲和力。回顾一下就不难发现，降临给自己的机会并没有增多，而自身能力也未曾见长。拒绝他人，远没有你想得那么糟，管理好属于你的时间，从说“不”开始！ 提问这是信息爆炸的时代，也是信息匮乏的时代。太多的信息跟太少的信息都是对认知的阻碍，因为我们失去甄别与提炼信息的能力了。学会提问，学会独立思考，洞察论据与论证的可靠性、逻辑性，通往合理结论的道路由提问开始，且一路有问题相伴。在这样一个信息泛滥的网络社会，保持自己独特的见解，建立一套有弹性的思维体系，再去看世界，必然有清晰的感知体验，就像《黑客帝国》中男主 NEO 看这个完全数字化的世界一样。人生的选择也可以通过追问得到答案，不少人面对职业选择的困惑，会去求助专业的生涯规划师，其实专家没替你做选择，只是通过提问让你清楚自己真正想要的以及为此能做出最大牺牲程度而已。提问比回答更有力量，多提问！ 慎独儒家的概念，用我自己的话来说就是「为了理想和目标，耐得住寂寞」，这是一种能力而非性格。也不与社交冲突，社交能力强的人也可以在独处时找到个体的平静与领悟。孤独是人生的主基调，而很多人都是尽量融入到人群中，减少独处的时间甚至逃避一个人的状况，这并不利于面对生活带来的挑战。不是鼓励大家去寻找孤单的小角落，会做饭与必须做，是两个概念，驾驭自己的独处时光，找到只属于自己的快乐，而不是寂寞带来的痛苦。新的一年，学会跟自己做朋友！ 自律自律不是自我牺牲，不是抑制欲望，因为长期来看，自律带给我们的效益使我们更接近自己的欲望。拿自己举例，给自己制定过无数次跑步计划，或者不开始，或者隔三差五跑了几次之后就放弃了。其实所有的不自律都是内心的渴望不够，谁不希望自己有个完美的身材体型呢，但谁会因为没有腹肌而想不开呢？我们也不愿意相信自己处于危险状态，认为自己身体很健康，就像在北京许多人不愿意戴口罩一样，好像戴上了就等于承认自己处于极端危险中。后来各种小毛病都指向运动健身这一解决方案，于是咬咬牙，坚持了一个月，越跑越轻松，而且不需要强大的毅力去支配，很自然就从计划事项转移到了常规事项，晚饭前运动1小时，结束后的成就感还能消除之前工作的疲惫。自律一开始很煎熬，时间长了却能给人自由，不自律只能放纵瞬间的快感，长期却带来了焦虑与自我否定。 新知只有竞争才能让自己意识到缺陷以及急切补救的心态，不久前才开始阅读计划，并且用思维导图做读书笔记，最大的好处就是思维层次复杂而有条理，知识变得多维度并且有结构化的体系，进而能够将不同书之间的相关理论串联起来，演绎推理能让人体察到不曾经历过的感悟。很多人存在这样的误区：经验是解决问题的至上法宝，人需要靠“经验自我”才能保持正确，例如“前人这么做失败了，所以我们不能这么做”、“中端智能手机不可能低于2000”，经验主义是创新的大敌，小米证明了这一点。所以事实上，我们需要学习“第一性原理”思考的埃隆·马斯克（特斯拉创始人），抓到本质后，从本质开始重新推演，才能不断逼近真相。2019，遇见更多的人和书！","categories":[{"name":"thinking","slug":"thinking","permalink":"https://kevinyangI.github.io/categories/thinking/"}],"tags":[{"name":"thinking","slug":"thinking","permalink":"https://kevinyangI.github.io/tags/thinking/"}],"keywords":[{"name":"thinking","slug":"thinking","permalink":"https://kevinyangI.github.io/categories/thinking/"}]},{"title":"写给工程师的十条精进的原则","slug":"写给工程师的十条精进的原则","date":"2018-09-23T13:48:55.000Z","updated":"2019-03-04T13:03:28.061Z","comments":true,"path":"2018/09/23/写给工程师的十条精进的原则/","link":"","permalink":"https://kevinyangI.github.io/kevinyangI.github.io/2018/09/23/写给工程师的十条精进的原则/","excerpt":"","text":"本文来自美团点评技术团队： 写给工程师的十条精进的原则 引言时间回到8年前，我人生中第一份实习的工作，是在某互联网公司的无线搜索部做一个C++工程师。当时的我可谓意气风发，想要大干一场，结果第一次上线就写了人生中第一个Casestudy。由于对部署环境的不了解，把SVN库里的配置文件错误地发到线上，并且上完线就去吃晚饭了，等吃饭回来发现师傅在焦头烂额地回滚配置。那次故障造成了一个核心服务20分钟不可用，影响了几百万的用户。这仅仅是一个开始，在后来半年的时间里，我几乎把所有职场新人可能犯的错误都犯了个遍。架构师让我调研一个抓取性能提升方案，我闷头搞了两周，也没有得出任何结论；本来安排好的开发计划，由于我临时要回去写论文，搞得经理措手不及；参加项目座谈会，全程“打酱油”……那段时间，自己也很苦恼，几乎每天晚上11点多才走，很累很辛苦，但依然拿不到想要的结果。 8年过去了，自己从一个职场小白逐步成长为一名技术Leader。我发现团队中的很多同学在不停地重复犯着自己当年类似的错误。他们并不是不努力，到底是哪里出了问题？经过一段时间的观察与思考后，我想我找到了答案。那就是：我们大多数同学在工作中缺乏原则的指导。原则，犹如指引行动的“灯塔”，它连接着我们的价值观与行动。不久前，桥水基金创始人雷·达里奥在《原则》一书中所传达的理念，引爆了朋友圈。每个人都应该有自己的原则，当我们需要作出选择时，一定要坚持以原则为中心。但是在现实生活中，我们往往缺少对原则的总结，对于很多人来说这是一门“只可意会不可言传”的玄学，是属于老司机的秘密，其实不然。 “追求卓越”是美团的价值观。作为一名技术人员，我们应该如何践行呢？本文总结了十条精进原则，希望能够给大家带来一些启发，更好地指导我们的行动。 原则一：Owner意识“Owner意识”主要体现在两个层面：一是认真负责的态度，二是积极主动的精神。 认真负责是工作的底线。首先，要对我们交付的结果负责。项目中每一个设计文档、每一行代码都需要认真完成，要对它的质量负责。如果设计文档逻辑混乱，代码没有注释，测试时发现一堆Bug，影响的不仅仅是RD的工程交付质量，还会对协同工作的RD、QA、PM等产生不好的影响。久而久之，团队的整体交付质量、工作效率也会逐步下降，甚至会导致团队成员之间产生不信任感。其次，我们要对开发的系统负责。系统的架构是否需要改进，接口文档是否完善，日志是否完整，数据库是否需要扩容，缓存空间够不够等等，这些都是需要落地的事情。作为系统Owner，请一定要认真履行。 积极主动是“Owner意识”更高一级的要求。RD每天要面对大量的工作，而且很多并不在计划内，这就需要具备一种积极主动的精神。例如我们每天可能会面对大量的技术咨询，如果客户提出的问题很长时间得不到回应的话，就会带来不好的客户体验。很多同学说忙于自己的工作没有时间处理，有同学觉得这件事不是很重要，也有很多同学是看到了，但是不知道怎么回答，更有甚者，看到了干脆装没看见。这些都是缺乏Owner意识的体现。正确的做法是积极主动地推动问题的解决，如果时间无法排开或者不知道如何解决，可以直接将问题反馈给能解决的同学。积极主动还可以表现在更多方面。比如很多同学会自发地梳理负责服务的现状，根据接口在性能方面暴露的问题提出改进意见并持续推动解决；也有同学在跨团队沟通中主动承担起主R的角色，积极发现问题、暴露问题，推动合作团队的进度，保证项目顺利推进。这些同学无一不是团队的中坚力量。所以，我们在做好自己份内工作的同时，也应该积极主动地投入到“份外”的工作中去。一分耕耘一分收获，不要给自己设限，努力成为一个更加优秀的人。 原则二：时间观念相信大家都有时间观念，但是真正能执行到位的可能并没有那么多。互联网是一个快速发展的行业，RD的研发效率是一个公司硬实力的重要体现。项目的按期交付是一项很重要的执行能力，在很大程度上决定着领导和同事对自己靠谱程度的评价。大家可能会问：难度几乎相同的项目，为什么有的同学经常Delay，而有的同学每次都能按时上线？一个很重要的原因，就是这些按时交付的同学往往具备如下两个特质：做事有计划，工作分主次。 工作安排要有计划性。通常，RD在设计评审之后就能预估出精确的开发时间，进而再合理地安排开发、联调、测试计划。如果是项目负责人，那么就会涉及协调FE、QA、PM等多个工种的同学共同完成工作。凡事预则立，不预则废。在计划制定过程中，要尽可能把每一项拆细一点（至少到pd粒度）。事实证明，粒度越细，计划就越精准，实际开发时间与计划之间的误差就会越小。此外，务必要规定明确的可检查的产出，并在计划中设置一些关键的时间点进行核对。无数血淋淋的事实告诉我们，很多项目延期都是因为在一些关键交付点上双方存在分歧造成的。例如后台RD的接口文档计划在周五提供，FE认为是周五上午，而RD认为是周五下班前提交，无形中会给排期带来了1pd的误差。所以，我们要做到计划粒度足够细，关键时间点要可检查。 工作安排要分清楚主次。我们每天要面对很多的事情，要学会分辨这些工作的主次。可以尝试使用“艾森豪威尔法则”（四象限法则），把工作按照重要、紧急程度分成四象限。优先做重要紧急的事情；重要不紧急的事情可以暂缓做，但是要持续推进；紧急不重要的事情可以酌情委托给最合适的人做；不重要不紧急的事情可以考虑不做。很多项目无法按期交付的原因，都是因为执行人分不清主次。比如在开发中需要使用到ES，一些不熟悉ES的同学可能想系统性地学习一下这方面的知识，就会一头扎进ES的汪洋中。最后才发现，原本一天就能完成的工作被严重拖后。实际工作中，我们应当避免这种“本末倒置”的工作方式。在本例中，“系统性地学习ES”是一件重要但不紧急的事情。要学会分辨出这些干扰的工作项，保证重要紧急的事情能够按时交付。 原则三：以终为始“以终为始”（Begin With The End In Mind），是史蒂芬·柯维在《高效能人士的七个习惯》中提到的一个习惯。它是以所有事物都经过两次创造的原则（第一次为心智上的创造，第二次为实际的创造）为基础的。直观的表达就是：先想清楚目标，然后努力实现。 在工作中，很多RD往往只是埋头走路，很少抬头看天。每次季度总结的时候，罗列了很多项目，付出很多努力。但是具体这些项目取得了哪些收益，对业务有哪些提升，却很难说出来。这就说明在工作中并没有遵守“以终为始”这一原则。此外，很多同学在做需求的过程中，对于目标与收益关注不够，系统上线之后，也没有持续地跟进使用效果。这一点在技术优化项目中体现得尤为明显。例如在一个接口性能优化的项目中，经过RD的努力优化，系统TP99缩短了60%，支持QPS提升了2倍。但是系统到底需要优化到什么程度呢？是不是缩短60%，提升2倍就能满足需求呢？在优化之前，很多同学常常忘记设置一个预设的目标（TP99小于多少，支持QPS大于多少）。我们必须清楚，优化一定是有原因的，比如预期某节假日流量会暴增或者某接口超时比例过高，如果不进行优化，系统可能会存在宕机风险。解决特定的问题才是技术优化的最终目的，所以要根据问题设定目标，再进行优化。 “以终为始”，这一原则还可以作用于我们的学习中。很多同学看过很多技术文章，但是总是感觉自己仍然一无所知。很重要的一个原因，就是没有带着目标去学习。在这个信息爆炸的时代，如果只是碎片化地接收各个公众号推送的文章，效果几乎可以忽略不计。在学习之前，我们一定要问自己，这次学习的目标是什么？是想把Redis的持久化原理搞清楚，还是把Redis的主从同步机制弄明白，亦或是想学习整个Redis Cluster的架构体系。如果我们能够带着问题与目标，再进行相关的资料搜集与学习，就会事半功倍。这种学习模式的效果会比碎片化阅读好很多。 原则四：闭环思维你是否遇到过这样的场景：参加了一个设计（或需求）评审，大家兴致勃勃地提了很多合理的意见，等到再次评审的时候，却发现第一次提的很多问题都没有得到改进，很多讨论过的问题需要从头再开始讨论。这种情况就是一种典型的工作不闭环。 之前看过一句话：一个人是否靠谱，就看他能否做到凡事有交代，件件有着落，事事有回音。这就是闭环思维的重要性。它强调的是一种即时反馈闭环，如果别人给我们分配了一个任务，不管完成的结果如何，一定要在规定的时间内给出明确的反馈。例如在跨部门的沟通会议中，虽然各方达成了一致，会议发起者已经将最终的记录周知大家。但是，到这一步其实并没有完成真正的闭环，在落地执行过程中很可能还存在一些潜在的问题。例如，会议纪要是否经各方仔细核对并确认过？会议中明确的To Do进展是什么？完成结果有没有Check的机制？如果这些没有做到的话，就会陷入“沟通-发现问题-再沟通-再发现问题”的恶性循环中。真正的闭环，要求我们对工作中的事情都能够养成良好的思维习惯，沟通要有结论，通知要有反馈，To Do要有验收。 “闭环思维”还要求能够定期主动进行阶段性的反馈。刚参加工作时，我接了一个工期为两个月的项目。整个项目需要独自完成，自己每天按照计划，有条不紊地进行开发。大概过了两周之后，Leader询问项目进度，虽然我已经跟他说没问题。然而，Leader告诉我，因为我每天对着电脑也不说话，让他心里很没底。这时，我才意识到一个很重要的问题，我跟Leader之间存在信息不对称。从那以后，我就时不时得跟他汇报一下进度，哪怕就只有简短的一句话，也可以明显感觉，他对我的信心增加了很多。特别是我做Leader之后，对这种闭环反馈的理解，就更加深刻了。从Leader的角度看，其实只是想知道项目是否在正常推进，是否遇到问题需要他协助解决。 原则五：保持敬畏“君子之心，常怀敬畏”，保持敬畏之心能够让我们少犯错误。在工作中存在各种各样的规范，例如代码规范、设计规范、上线规范等等。我们必须明白，这些规范的制定一定是基于某些客观原因的，它们都是历史上无数Case积累而来的经验。团队里的每一个成员都应该学习并严格遵守，这一点对于新人尤其重要。 当我们进入到一个新的团队，请先暂时忘掉之前的习惯，要尽快学习团队既有的规范，并且让自己与团队保持一致。以编码风格为例，很多同学往往习惯于自己之前的代码写作风格，在做新公司第一个项目时，也按照自己的习惯进行变量、包的命名等等。结果在代码Review过程中，被提了很多修改意见，不得不返工重写，得不偿失。如果能够保持敬畏之心，提前了解编码规范，这种问题完全可以避免。类似的问题，还包括对上线流程不了解，对回滚操作不熟悉，对SRE线上变更过程不了解等等。除了这些显而易见的规范，还有一些约定俗成的规则。个人建议是：如果有事情拿不准，不妨多问问其他同事，不要凭自己的感觉做事情。 保持敬畏之心并不意味着要“因循守旧”。在我们充分了解这些规范和约定之后，如果觉得存在不妥之处，可以跟全组同学讨论，是否采纳新的建议，然后及时去更新迭代。其实，让规范与约定与时俱进，也是另一种形式的敬畏。 原则六：事不过二“事不过二”，是我们团队一贯坚持的原则，它可以解读为两层含义。 一层含义是“所有的评审与问题讨论，不要超过两次”。之所以有这样的要求，是因为我们发现，很多RD都把时间花费在一些无休止的评审与问题讨论中，真正投入到实际开发中的时间反而很少。在实际工作场景中，我们经常会遇到一些不是很成熟的需求评审。这些需求文档，要么是背景与目标含糊不清，要么是产品方案描述不够细化，或者存在歧义。RD与PM被迫反复进行讨论，我曾经遇到过一个需求评审，进行了三次还被打回。同样的问题，在设计评审中也屡见不鲜。方案固然需要经过反复的讨论，但是如果迟迟不能达成一致，就会耗费很多RD与PM的宝贵时间，这就与提升研发效率的理念背道而驰。因此，我们团队规定：所有的评审最多两次。通过这种方式，倒逼利益相关方尽可能地做好需求与方案设计。评审会议组织前，尝试与所有相关人员达成一致，询问对方的意见，并进行有针对性的讨论，这样能够大大提升评审会议的效率和质量。如果在第一次评审中不通过，那么就只有一次机会进行复审。一旦两次不通过，就需要进行Casestudy。 “事不过二”原则的另一层含义，是“同样的错误不能犯第二次”。每次故障之后，Casestudy都必须进行深刻的总结复盘，对故障原因进行5Why分析，给出明确可执行的To Do List。每次季度总结会，大家自我反省问题所在，在下个季度必须有所改善，不能再犯类似的错误。孔子云：“不迁怒，不贰过”，在错误中反思与成长，才能让我们成为更优秀的人。 原则七：设计优先“设计优先”这条原则，相对来说更加具体一些。之所以单列一项，是因为架构设计太重要了。Uncle Bob曾说过：“软件架构的目标，是为了让构建与维护系统的所需人力资源最小化。” 架构设计，并不仅仅关系到系统的质量，还关乎团队的效能问题。很多团队也有明文规定，开发周期在3pd以上的项目必须有设计文档，开发周期在5pd以上的项目必须有设计评审。在具体的执行过程中，由于各种原因，设计往往并不能达到预期的效果。究其原因，有的是因为项目周期紧，来不及设计得足够详细；有的是因为RD主观上认为项目比较简单，设计草草了事。无数事实证明，忽略了前期设计，往往会导致后续开发周期被大幅拉长，给项目带来了很大的Delay风险。而且最可怕的是，不当的设计会给项目带来巨大的后期维护成本，我们不得不腾出时间，专门进行项目的优化与重构。因此，无论什么时候都要记住“设计优先”这一原则。磨刀不误砍柴工，前期良好的设计，会给项目开发以及后期维护带来极大的收益。 “设计优先”这一原则，要求写别人看得懂的设计。我们了解一个系统最直接的途径就是结合设计文档与代码。在实际工作中，很多同学的设计文档让大家看得一头雾水，通篇下来，看不出系统整体的设计思路。其实，设计的过程是一种智力上的创造，我们更希望它能成为个人与集体智慧的结晶。如何才能让我们的设计变得通俗易懂？我个人认为，设计应该尽量使用比较合理的逻辑，进而把设计中的一些点组织起来。比如可以使用从抽象到具体，由总到分的结构来组织材料。在设计过程中，要以需求为出发点，通过合理的抽象把问题简化，讲清楚各个模块之间的关系，再详细分述模块的实现细节。做完设计之后，可以发给比较资深的RD或者PM审阅一下，根据他们的反馈再进行完善。好的设计，一定是逻辑清晰易懂、细节落地可执行的。 原则八：P/PC平衡“P/PC平衡”原则，即产出与产能平衡原则。伊索寓言中讲述了一个《生金蛋的鹅》的故事。产出好比“金蛋”，产能好比“会下金蛋的鹅”。“重蛋轻鹅”的人，最终可能连产蛋的资产都保不住；“重鹅轻蛋”的人，最终可能会被饿死。产出与产能必须平衡，才能达到真正的高效能。为了让大家更清晰的了解这一原则，本文举两个例子。 从系统的角度看，每一个系统都是通过持续不断地叠加功能来实现其产出，而系统的产能是通过系统架构的可扩展性、稳定性等一系列特性来表征。为了达到产出与产能的平衡，需要在不断支持业务需求的过程中，持续进行技术架构层面的优化。如果一味地做业务需求，经过一定的时间，系统会越来越慢，最终影响业务的稳定性；反之，一个没有任何业务产出的系统，最终会消亡。 再从RD的角度来看这个问题，RD通过做需求来给公司创造价值，实现自己的产出。而RD的产能是指技术能力、软素质、身体健康状况，有这些资本后，我们才能进行持续的产出。在日常工作中，我发现很多RD往往只重视产出。他们也在很努力地做项目，但是每一个项目所使用的方法，还是沿用自己先前一贯的思路。最终，不仅项目做得一般，还会抱怨自己得不到任何成长。这就是P/PC不平衡的体现。如果能在做项目的过程中，通过学习总结持续提升自己的技术能力和软素质，并将其应用于项目实施交付中，相信一定会取得双赢的结果。 “P/PC平衡”原则还适用于很多其他的领域，例如团队、家庭等，我本人也非常推崇这一原则。希望大家也能将其作为自身的一项基本原则，努力寻找到产出与产能的平衡点。 原则九：善于提问“善于提问”，首先要勤于提问。求知欲源于好奇心，是人类的一种本能。在工作中要养成勤于提问的好习惯，不懂就问，不要因为自己一时懒惰或者碍于情面，就放弃提问的机会。当遇到不同的观点时，也要礼貌地问出来。波克定理告诉我们，只有在争辩中，才可能诞生最好的主意和最好的决定。 在设计评审、代码评审这类体现集体智慧的活动中，遇到有问题的地方一定要提出来。我经常看到，很多同学评审全程一言不发，这就是浪费大家的时间。设计评审的目的，是让大家针对方案提出改进意见并达成一致，如果全程“打酱油”，那就失去了评审的意义。我们鼓励大家多提问，把自己内心的疑惑表达出来，然后通过交流的方式得到答案。 “善于提问”，还要懂得如何提问。为什么同样是参加设计评审，有的同学就能提出很好的问题，而有的同学却提不出任何问题？除了知识储备、专业技能、经验等方面的差异外，还有一点很重要：批判性思维。 批判性思维主张通过批判性思考达到理性思维，即对事物本质的认知和掌握。关于如何进行批判性思维，大家可以参考一些经典的图书如《批判性思维》、《学会提问》等。在工作中面临一项决策时，会有各种各样的意见摆在你面前，所以我们必须要学会使用批判性思维来进行分析，每个人的论据是否可靠，论证是否合理，是否有隐含的立场。同样，在阅读一篇技术博客的时候，也要使用批判性的思维，多问几个为什么，作者得出的结论是否合理？论据是否充分？只有这样，才能不断地获取真正的知识。 原则十：空杯心态“满招损，谦受益”，“空杯心态”是最后一项原则。我觉得这也是一个人能够持续成长的前提。做技术的人，骨子里通常有股傲气，并且会随着资历、成绩的提升而不断增加。初入职场的小白，可能会非常谦虚，但是工作几年之后，专业技能逐步提升，可能还取得了一些小成就，人就会越来越自信。这时候，如果不能始终保持“空杯心态”，这种自信就会逐步演变为自满。自满的人，往往表现为工作中把别人的建议当成是批评，不接受任何反对意见，学习上也缺乏求知的动力，总是拿自己的长处去跟别人的短处做比较。其实每个人多少都会有一些自满，可怕的是不知道甚至不愿承认自满。 保持“空杯心态”这一原则要求我们时刻进行自我检视与反省。在工作中，多去跟不同级别的同学聊一聊，或者做一个360度评估，这有助于我们更加客观地评价自己。在横向对比中，多向那些优秀的同学看齐，学习他人的优点。很多同学在设计评审或者代码review过程中，针对别人提出的问题与建议，往往都采用一种对立的态度。错误地认为别人是在挑刺，是在针对自己。诚然，在某些方面，我们可能确实比其他人想得深入，但是这不代表在所有方面都能考虑周全。对于别人的建议，建议使用“善于提问”原则里提到的批判性思维仔细分析一下，虚心地吸取那些好的建议。 工作学习就像“练级打怪”，技能储备的越多，就越容易走到最后。保持空杯心态，可以让我们发现很多以前注意不到的新能力，我们要做的就是努力学习它，将它们转化为自己能力库的一部分。 总结以上，是我总结的工作与学习的十条基本原则。其中有的侧重于个人做事情的方法，如“Owner意识”、“时间观念”、“以终为始”、”闭环思维”；有的侧重于团队工作标准规范，如“保持敬畏”、“事不过二”、“设计优先”；有的侧重于团队或个人效能提升，如“P/PC平衡”、“善于提问”、“空杯心态”。这些原则是我多年在工作与学习中，不断总结得来的经验。希望在大家面临选择时，这些原则能够起到一定的帮助和指导作用。 以原则为中心地工作与生活，让自己与团队变得更加强大。 作者介绍云鹏，2014年加入美团，先后参与了美团酒店供应链体系、分布式调度系统的建设，现在负责美团旅行客户关系管理系统、基础信息服务的建设工作。","categories":[{"name":"thinking","slug":"thinking","permalink":"https://kevinyangI.github.io/categories/thinking/"}],"tags":[{"name":"thinking","slug":"thinking","permalink":"https://kevinyangI.github.io/tags/thinking/"}],"keywords":[{"name":"thinking","slug":"thinking","permalink":"https://kevinyangI.github.io/categories/thinking/"}]},{"title":"如何在 Java 中避免 equals 方法的隐藏陷阱","slug":"如何在 Java 中避免 equals 方法的隐藏陷阱","date":"2018-08-16T03:58:55.000Z","updated":"2018-09-02T12:14:42.523Z","comments":true,"path":"2018/08/16/如何在 Java 中避免 equals 方法的隐藏陷阱/","link":"","permalink":"https://kevinyangI.github.io/kevinyangI.github.io/2018/08/16/如何在 Java 中避免 equals 方法的隐藏陷阱/","excerpt":"","text":"译文原文： 如何在 Java 中避免 equals 方法的隐藏陷阱英文原文： How to Write an Equality Method in Java 摘要本文描述重载 equals 方法的技术，这种技术即使是具现类的子类增加了字段也能保证 equal 语义的正确性。 在《Effective Java》的第 8 项中，Josh Bloch 描述了当继承类作为面向对象语言中的等价关系的基础问题，要保证派生类的 equal 正确性语义所会面对的困难。Bloch 这样写到： 除非你忘记了面向对象抽象的好处，否则在当你继承一个新类或在类中增加了一个值组件时你无法同时保证 equal 的语义依然正确。 在《Programming in Scala》中的第 28 章演示了一种方法，这种方法允许即使继承了新类，增加了新的值组件，equal 的语义仍然能得到保证。虽然在这本书中这项技术是在使用 Scala 类环境中，但是这项技术同样可以应用于 Java 定义的类中。在本文中的描述来自于 Programming in Scala 中的文字描述，但是代码被我从 scala 翻译成了 Java。 常见的等价方法陷阱java.lang.Object 类定义了 equals 这个方法，它的子类可以通过重载来覆盖它。不幸的是，在面向对象中写出正确的 equals 方法是非常困难的。事实上，在研究了大量的 Java 代码后，2007 paper 的作者得出了如下的一个结论： 几乎所有的equals方法的实现都是错误的！ 这个问题是因为等价是和很多其他的事物相关联。例如其中之一，一个的类型C的错误等价方法可能意味着你无法将这个类型C的对象可信赖的放入到容器中。比如说，你有两个元素 elem1 和 elem2 他们都是类型 C 的对象，并且他们是相等，即 elem1.equals(elm2) 返回 ture。但是，只要这个 equals 方法是错误的实现，那么你就有可能会看见如下的一些行为： 123Set hashSet&lt;C&gt; = new java.util.HashSet&lt;C&gt;();hashSet.add(elem1);hashSet.contains(elem2); // returns false!&lt;/pre&gt; 当 equals 重载时，这里有 4 个会引发 equals 行为不一致的常见陷阱： 1、定义了错误的 equals 方法签名(signature)。Defining equals with the wrong signature. 2、重载了 equals 方法但没有同时重载 hashCode 方法。Changing equals without also changing hashCode. 3、建立在会变化字域上的 equals 定义。Defining equals in terms of mutable fields. 4、不满足等价关系的 equals 错误定义。Failing to define equals as an equivalence relation. 在剩下的章节中我们将依次讨论这 4 种陷阱。 陷阱1：定义错误 equals 方法签名(signature)考虑为下面这个简单类 Point 增加一个等价性方法：1234567891011121314151617181920public class Point &#123; private final int x; private final int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public int getY() &#123; return y; &#125; // ...&#125; 看上去非常明显，但是按照这种方式来定义 equals 就是错误的。1234// An utterly wrong definition of equalspublic boolean equals(Point other) &#123; return (this.getX() == other.getX() &amp;&amp; this.getY() == other.getY());&#125; 这个方法有什么问题呢？初看起来，它工作的非常完美：12345678Point p1 = new Point(1, 2);Point p2 = new Point(1, 2);Point q = new Point(2, 3);System.out.println(p1.equals(p2)); // prints trueSystem.out.println(p1.equals(q)); // prints false 然而，当我们一旦把这个 Point 类的实例放入到一个容器中问题就出现了： 123456import java.util.HashSet;HashSet&lt;Point&gt; coll = new HashSet&lt;Point&gt;();coll.add(p1);System.out.println(coll.contains(p2)); // prints false 为什么 coll 中没有包含 p2 呢？甚至是 p1 也被加到集合里面，p1 和 p2 是是等价的对象吗？在下面的程序中，我们可以找到其中的一些原因，定义 p2a 是一个指向 p2 的对象，但是 p2a 的类型是 Object 而非 Point 类型：1Object p2a = p2; 现在我们重复第一个比较，但是不再使用 p2 而是 p2a，我们将会得到如下的结果：1System.out.println(p1.equals(p2a)); // prints false 到底是那里出了了问题？事实上，之前所给出的 equals 版本并没有覆盖 Object 类的 equals 方法，因为他的类型不同。下面是 Object 的 equals 方法的定义：1public boolean equals(Object other) 因为 Point 类中的 equals 方法使用的是以 Point 类而非 Object 类做为参数，因此它并没有覆盖 Object 中的 equals 方法。而是一种变化了的重载。在 Java 中重载被解析为静态的参数类型而非运行期的类型，因此当静态参数类型是 Point，Point 的 equals 方法就被调用。然而当静态参数类型是 Object 时，Object 类的 equals 就被调用。因为这个方法并没有被覆盖，因此它仍然是实现成比较对象标示。这就是为什么虽然 p1 和 p2a 具有同样的 x，y 值， “p1.equals(p2a)” 仍然返回了 false。这也是会什么 HasSet 的 contains 方法返回 false 的原因，因为这个方法操作的是泛型，他调用的是一般化的 Object 上 equals 方法而非 Point 类上变化了的重载方法 equals。 一个更好但不完美的equals方法定义如下：12345678910// A better definition, but still not perfect@Overridepublic boolean equals(Object other) &#123; boolean result = false; if (other instanceof Point) &#123; Point that = (Point) other; result = (this.getX() == that.getX() &amp;&amp; this.getY() == that.getY()); &#125; return result;&#125; 现在 equals 有了正确的类型，它使用了一个 Object 类型的参数和一个返回布尔型的结果。这个方法的实现使用 instanceof 操作和做了一个造型。它首先检查这个对象是否是一个 Point 类，如果是，他就比较两个点的坐标并返回结果，否则返回 false。 陷阱2：重载了 equals 的但没有同时重载 hashCode 的方法如果你使用上一个定义的 Point 类进行 p1 和 p2a 的反复比较，你都会得到你预期的 true 的结果。但是如果你将这个类对象放入到 HashSet.contains() 方法中测试，你就有可能仍然得到 false 的结果：1234567Point p1 = new Point(1, 2);Point p2 = new Point(1, 2);HashSet&lt;Point&gt; coll = new HashSet&lt;Point&gt;();coll.add(p1);System.out.println(coll.contains(p2)); // 打印 false (有可能) 事实上，这个个结果不是 100% 的 false，你也可能有返回 ture 的经历。如果你得到的结果是 true 的话，那么你试试其他的坐标值，最终你一定会得到一个在集合中不包含的结果。导致这个结果的原因是 Point 重载了 equals 却没有重载 hashCode。 注意上面例子的的容器是一个 HashSet，这就意味着容器中的元素根据他们的哈希码被被放入到 “哈希桶 hash buckets” 中。contains 方法首先根据哈希码在哈希桶中查找，然后让桶中的所有元素和所给的参数进行比较。现在，虽然最后一个 Point 类的版本重定义了 equals 方法，但是它并没有同时重定义 hashCode。因此，hashCode 仍然是 Object 类的那个版本，即：所分配对象的一个地址的变换。所以 p1 和 p2 的哈希码理所当然的不同了，甚至是即时这两个点的坐标完全相同。不同的哈希码导致他们具有极高的可能性被放入到集合中不同的哈希桶中。contains 方法将会去找 p2 的哈希码对应哈希桶中的匹配元素。但是大多数情况下，p1 一定是在另外一个桶中，因此，p2 永远找不到 p1 进行匹配。当然 p1 和 p2 也可能偶尔会被放入到一个桶中，在这种情况下，contains 的结果就为true了。 最新一个 Point 类实现的问题是，它的实现违背了作为 Object 类的定义的 hashCode 的语义。 如果两个对象根据 equals(Object) 方法是相等的，那么在这两个对象上调用 hashCode 方法应该产生同样的值。 事实上，在 Java 中，hashCode 和 equals 需要一起被重定义是众所周知的。此外，hashCode 只可以依赖于 equals 依赖的域来产生值。对于 Point 这个类来说，下面的的 hashCode 定义是一个非常合适的定义。 12345678910111213141516171819202122232425262728293031323334public class Point &#123; private final int x; private final int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public int getY() &#123; return y; &#125; @Override public boolean equals(Object other) &#123; boolean result = false; if (other instanceof Point) &#123; Point that = (Point) other; result = (this.getX() == that.getX() &amp;&amp; this.getY() == that.getY()); &#125; return result; &#125; @Override public int hashCode() &#123; return (41 * (41 + getX()) + getY()); &#125;&#125; 这只是 hashCode 一个可能的实现。x 域加上常量 41 后的结果再乘与 41 并将结果在加上 y 域的值。这样做就可以以低成本的运行时间和低成本代码大小得到一个哈希码的合理的分布。 增加 hashCode 方法重载修正了定义类似 Point 类等价性的问题。然而，关于类的等价性仍然有其他的问题点待发现。 陷阱3：建立在会变化字段上的equals定义让我们在 Point 类做一个非常微小的变化： 1234567891011121314151617181920212223242526272829303132333435363738394041public class Point &#123; private int x; private int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public int getY() &#123; return y; &#125; public void setX(int x) &#123; // Problematic this.x = x; &#125; public void setY(int y) &#123; this.y = y; &#125; @Override public boolean equals(Object other) &#123; boolean result = false; if (other instanceof Point) &#123; Point that = (Point) other; result = (this.getX() == that.getX() &amp;&amp; this.getY() == that.getY()); &#125; return result; &#125; @Override public int hashCode() &#123; return (41 * (41 + getX()) + getY()); &#125;&#125; 唯一的不同是 x 和 y 域不再是 final，并且两个 set 方法被增加到类中来，并允许客户改变 x 和 y 的值。equals 和 hashCode 这个方法的定义现在是基于在这两个会发生变化的域上，因此当他们的域的值改变时，结果也就跟着改变。因此一旦你将这个 point 对象放入到集合中你将会看到非常神奇的效果。123456Point p = new Point(1, 2);HashSet&lt;Point&gt; coll = new HashSet&lt;Point&gt;();coll.add(p);System.out.println(coll.contains(p)); // 打印 true 现在如果你改变 p 中的一个域，这个集合中还会包含 point 吗？我们将拭目以待。123p.setX(p.getX() + 1);System.out.println(coll.contains(p)); // (有可能)打印 false 看起来非常的奇怪。p 去哪里去了？如果你通过集合的迭代器来检查 p 是否包含，你将会得到更奇怪的结果。1234567891011Iterator&lt;Point&gt; it = coll.iterator();boolean containedP = false;while (it.hasNext()) &#123; Point nextP = it.next(); if (nextP.equals(p)) &#123; containedP = true; break; &#125;&#125;System.out.println(containedP); // 打印 true 结果是，集合中不包含 p，但是 p 在集合的元素中！到底发生了什么！当然，所有的这一切都是在 x 域的修改后才发生的，p 最终的的 hashCode 是在集合 coll 错误的哈希桶中。即，原始哈希桶不再有其新值对应的哈希码。换句话说，p 已经在集合 coll 的视野范围之外，虽然他仍然属于 coll 的元素。 从这个例子所得到的教训是，当 equals 和 hashCode 依赖于会变化的状态时，那么就会给用户带来问题。如果这样的对象被放入到集合中，用户必须小心，不要修改这些这些对象所依赖的状态，这是一个小陷阱。如果你需要根据对象当前的状态进行比较的话，你应该不要再重定义 equals，应该起其他的方法名字而不是 equals。对于我们的 Point 类的最后的定义，我们最好省略掉 hashCode 的重载，并将比较的方法名命名为 equalsContents，或其他不同于 equals 的名字。那么 Point 将会继承原来默认的 equals 和 hashCode 的实现，因此当我们修改了 x 域后 p 依然会呆在其原来在容器中应该在位置。 陷阱4：不满足等价关系的equals错误定义Object 中的 equals 的规范阐述了 equals 方法必须实现在非 null 对象上的等价关系： 自反原则：对于任何非 null 值 X，表达式 x.equals(x) 总返回 true。 等价性：对于任何非空值 x 和 y，那么当且仅当 y.equals(x) 返回真时，x.equals(y) 返回真。 传递性：对于任何非空值 x，y 和 z，如果 x.equals(y) 返回真，且 y.equals(z) 也返回真，那么 x.equals(z) 也应该返回真。 一致性：对于非空 x，y，多次调用 x.equals(y) 应该一致的返回真或假。提供给 equals 方法比较使用的信息不应该包含改过的信息。 对于任何非空值 x，x.equals(null) 应该总返回 false. Point 类的 equals 定义已经被开发成了足够满足 equals 规范的定义。然而，当考虑到继承的时候，事情就开始变得非常复杂起来。比如说有一个 Point 的子类 ColoredPoint，它比 Point 多增加了一个类型是 Color 的 color 域。假设 Color 被定义为一个枚举类型： 123public enum Color &#123; RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET;&#125; ColoredPoint 重载了 equals 方法，并考虑到新加入 color 域，代码如下：12345678910111213141516171819public class ColoredPoint extends Point &#123; // Problem: equals not symmetric private final Color color; public ColoredPoint(int x, int y, Color color) &#123; super(x, y); this.color = color; &#125; @Override public boolean equals(Object other) &#123; boolean result = false; if (other instanceof ColoredPoint) &#123; ColoredPoint that = (ColoredPoint) other; result = (this.color.equals(that.color) &amp;&amp; super.equals(that)); &#125; return result; &#125;&#125; 这是很多程序员都有可能写成的代码。注意在本例中，类 ColoredPointed 不需要重载 hashCode，因为新的 ColoredPoint 类上的 equals 定义，严格的重载了 Point上equals 的定义。hashCode 的规范仍然是有效，如果两个着色点 (colored point) 相等，其坐标必定相等，因此它的 hashCode 也保证了具有同样的值。 对于 ColoredPoint 类自身对象的比较是没有问题的，但是如果使用 ColoredPoint 和 Point 混合进行比较就要出现问题。 1234567Point p = new Point(1, 2);ColoredPoint cp = new ColoredPoint(1, 2, Color.RED);System.out.println(p.equals(cp)); // 打印真 trueSystem.out.println(cp.equals(p)); // 打印假 false “p等价于cp” 的比较这个调用的是定义在 Point 类上的 equals 方法。这个方法只考虑两个点的坐标。因此比较返回真。在另外一方面，“cp等价于p” 的比较这个调用的是定义在 ColoredPoint 类上的 equals 方法，返回的结果却是 false，这是因为 p 不是 ColoredPoint，所以 equals 这个定义违背了对称性。 违背对称性对于集合来说将导致不可以预期的后果，例如：1234567Set&lt;Point&gt; hashSet1 = new java.util.HashSet&lt;Point&gt;();hashSet1.add(p);System.out.println(hashSet1.contains(cp)); // 打印 falseSet&lt;Point&gt; hashSet2 = new java.util.HashSet&lt;Point&gt;();hashSet2.add(cp);System.out.println(hashSet2.contains(p)); // 打印 true 因此虽然 p 和 cp 是等价的，但是 contains 测试中一个返回成功，另外一个却返回失败。 你如何修改 equals 的定义，才能使得这个方法满足对称性？本质上说有两种方法，你可以使得这种关系变得更一般化或更严格。更一般化的意思是这一对对象，a 和 b，被用于进行对比，无论是 a 比 b 还是 b 比 a 都返回true，下面是代码： 1234567891011121314151617181920212223public class ColoredPoint extends Point &#123; // Problem: equals not transitive private final Color color; public ColoredPoint(int x, int y, Color color) &#123; super(x, y); this.color = color; &#125; @Override public boolean equals(Object other) &#123; boolean result = false; if (other instanceof ColoredPoint) &#123; ColoredPoint that = (ColoredPoint) other; result = (this.color.equals(that.color) &amp;&amp; super.equals(that)); &#125; else if (other instanceof Point) &#123; Point that = (Point) other; result = that.equals(this); &#125; return result; &#125;&#125; 在 ColoredPoint 中的 equals 的新定义比老定义中检查了更多的情况：如果对象是一个 Point 对象而不是 ColoredPoint，方法就转变为 Point 类的 equals 方法调用。这个所希望达到的效果就是 equals 的对称性，不管 “cp.equals(p)” 还是 “p.equals(cp)” 的结果都是 true。然而这种方法，equals 的规范还是被破坏了，现在的问题是这个新等价性不满足传递性。考虑下面的一段代码实例，定义了一个点和这个点上上两种不同颜色点：12ColoredPoint redP = new ColoredPoint(1, 2, Color.RED);ColoredPoint blueP = new ColoredPoint(1, 2, Color.BLUE); redP 等价于 p，p 等价于 blueP123System.out.println(redP.equals(p)); // prints trueSystem.out.println(p.equals(blueP)); // prints true 然而，对比 redP 和 blueP 的结果是 false:1System.out.println(redP.equals(blueP)); // 打印 false 因此，equals的传递性就被违背了。 使 equals 的关系更一般化似乎会将我们带入到死胡同。我们应该采用更严格化的方法。一种更严格化的 equals 方法是认为不同类的对象是不同的。这个可以通过修改 Point 类和 ColoredPoint 类的 equals 方法来达到。你能增加额外的比较来检查是否运行态的这个 Point 类和那个 Point 类是同一个类，就像如下所示的代码一样：1234567891011121314151617181920212223242526272829303132333435// A technically valid, but unsatisfying, equals methodpublic class Point &#123; private final int x; private final int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public int getY() &#123; return y; &#125; @Override public boolean equals(Object other) &#123; boolean result = false; if (other instanceof Point) &#123; Point that = (Point) other; result = (this.getX() == that.getX() &amp;&amp; this.getY() == that.getY() &amp;&amp; this.getClass().equals(that.getClass())); &#125; return result; &#125; @Override public int hashCode() &#123; return (41 * (41 + getX()) + getY()); &#125;&#125; 这里，Point类的实例只有当和另外一个对象是同样类，并且有同样的坐标时候，他们才被认为是相等的，即意味着 .getClass()返回的是同样的值。这个新定义的等价关系满足了对称性和传递性因为对于比较对象是不同的类时结果总是false。所以着色点(colored point)永远不会等于点(point)。通常这看起来非常合理，但是这里也存在着另外一种争论——这样的比较过于严格了。 考虑我们如下这种稍微的迂回的方式来定义我们的坐标点(1,2) 12345Point pAnon = new Point(1, 1) &#123; @Override public int getY() &#123; return 2; &#125;&#125;; pAnon 等于 p 吗？答案是假，因为 p 和 pAnon 的 java.lang.Class 对象不同。p 是 Point，而 pAnon 是 Point 的一个匿名派生类。但是，非常清晰的是 pAnon 的确是在坐标1，2上的另外一个点。所以将他们认为是不同的点是没有理由的。 canEqual 方法到此，我们看其来似乎是遇到阻碍了，存在着一种正常的方式不仅可以在不同类继承层次上定义等价性，并且保证其等价的规范性吗？事实上，的确存在这样的一种方法，但是这就要求除了重定义 equals 和 hashCode 外还要另外的定义一个方法。基本思路就是在重载 equals (和 hashCode) 的同时，它应该也要要明确的声明这个类的对象永远不等价于其他的实现了不同等价方法的超类的对象。为了达到这个目标，我们对每一个重载了 equals 的类新增一个方法 canEqual 方法。这个方法的方法签名是： 1public boolean canEqual(Object other) 如果 other 对象是 canEquals (重)定义那个类的实例时，那么这个方法应该返回真，否则返回 false。这个方法由 equals 方法调用，并保证了两个对象是可以相互比较的。下面 Point 类的新的也是最终的实现：12345678910111213141516171819202122232425262728293031323334353637public class Point &#123; private final int x; private final int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public int getY() &#123; return y; &#125; @Override public boolean equals(Object other) &#123; boolean result = false; if (other instanceof Point) &#123; Point that = (Point) other; result =(that.canEqual(this) &amp;&amp; this.getX() == that.getX() &amp;&amp; this.getY() == that.getY()); &#125; return result; &#125; @Override public int hashCode() &#123; return (41 * (41 + getX()) + getY()); &#125; public boolean canEqual(Object other) &#123; return (other instanceof Point); &#125;&#125; 这个版本的 Point 类的 equals 方法中包含了一个额外的需求，通过 canEquals 方法来决定另外一个对象是否是是满足可以比较的对象。在 Point 中的 canEqual 宣称了所有的 Point 类实例都能被比较。 下面是 ColoredPoint 相应的实现：1234567891011121314151617181920212223242526272829public class ColoredPoint extends Point &#123; // 不再违背对称性 private final Color color; public ColoredPoint(int x, int y, Color color) &#123; super(x, y); this.color = color; &#125; @Override public boolean equals(Object other) &#123; boolean result = false; if (other instanceof ColoredPoint) &#123; ColoredPoint that = (ColoredPoint) other; result = (that.canEqual(this) &amp;&amp; this.color.equals(that.color) &amp;&amp; super.equals(that)); &#125; return result; &#125; @Override public int hashCode() &#123; return (41 * super.hashCode() + color.hashCode()); &#125; @Override public boolean canEqual(Object other) &#123; return (other instanceof ColoredPoint); &#125;&#125; 在上显示的新版本的 Point 类和 ColoredPoint 类定义保证了等价的规范。等价是对称和可传递的。比较一个 Point 和 ColoredPoint 类总是返回 false。因为点 p 和着色点 cp，“p.equals(cp) 返回的是假。并且，因为 cp.canEqual(p) 总返回 false。相反的比较，cp.equals(p) 同样也返回 false，由于 p 不是一个 ColoredPoint，所以在 ColoredPoint 的 equals 方法体内的第一个 instanceof 检查就失败了。 另外一个方面，不同的 Point 子类的实例却是可以比较的，同样没有重定义等价性方法的类也是可以比较的。对于这个新类的定义，p 和 pAnon 的比较将总返回 true。下面是一些例子： 123456789101112131415161718Point p = new Point(1, 2);ColoredPoint cp = new ColoredPoint(1, 2, Color.INDIGO);Point pAnon = new Point(1, 1) &#123; @Override public int getY() &#123; return 2; &#125;&#125;;Set&lt;Point&gt; coll = new java.util.HashSet&lt;Point&gt;();coll.add(p);System.out.println(coll.contains(p)); // 打印 trueSystem.out.println(coll.contains(cp)); // 打印 falseSystem.out.println(coll.contains(pAnon)); // 打印 true 这些例子显示了如果父类在 equals 的实现定义并调用了 canEquals，那么开发人员实现的子类就能决定这个子类是否可以和它父类的实例进行比较。例如 ColoredPoint，因为它以 “一个着色点永远不可以等于普通不带颜色的点重载了” canEqual，所以他们就不能比较。但是因为 pAnon 引用的匿名子类没有重载 canEqual，因此它的实例就可以和 Point 的实例进行对比。 canEqual 方法的一个潜在的争论是它是否违背了 Liskov 替换准则(LSP)。例如，通过比较运行态的类来实现的比较技术(译者注： canEqual的前一版本，使用.getClass()的那个版本)，将导致不能定义出一个子类，这个子类的实例可以和其父类进行比较，因此就违背了LSP。这是因为，LSP 原则是这样的，在任何你能使用父类的地方你都可以使用子类去替换它。在之前例子中，虽然 cp 的 x，y 坐标匹配那些在集合中的点，然而 “coll.contains(cp)” 仍然返回 false，这看起来似乎违背得了 LSP 准则，因为你不能这里能使用 Point 的地方使用一个 ColoredPointed。但是我们认为这种解释是错误的，因为 LSP 原则并没有要求子类和父类的行为一致，而仅要求其行为能一种方式满足父类的规范。 通过比较运行态的类来编写 equals 方法(译者注：canEqual 的前一版本，使用 .getClass() 的那个版本)的问题并不是违背 LSP 准则的问题，但是它也没有为你指明一种创建派生类的实例能和父类实例进行对比的的方法。例如，我们使用这种运行态比较的技术在之前的 “coll.contains(pAnon)” 将会返回 false，并且这并不是我们希望的。相反我们希望 “coll.contains(cp)” 返回 false，因为通过在 ColoredPoint 中重载的 equals，我基本上可以说，一个在坐标 1，2 上着色点和一个坐标 1，2 上的普通点并不是一回事。然而，在最后的例子中，我们能传递 Point 两种不同的子类实例到集合中 contains 方法，并且我们能得到两个不同的答案，并且这两个答案都正确。","categories":[{"name":"Java","slug":"Java","permalink":"https://kevinyangI.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://kevinyangI.github.io/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://kevinyangI.github.io/categories/Java/"}]},{"title":"理解 ==、equals 和 hashcode 的区别","slug":"理解==、equals 和 hashcode 的区别","date":"2018-08-16T02:37:50.000Z","updated":"2018-09-02T09:40:07.212Z","comments":true,"path":"2018/08/16/理解==、equals 和 hashcode 的区别/","link":"","permalink":"https://kevinyangI.github.io/kevinyangI.github.io/2018/08/16/理解==、equals 和 hashcode 的区别/","excerpt":"","text":"==java 中的数据类型，可分为两类： 1、基本数据类型byte，short，char，int，long，float，double，boolean 他们之间的比较，应用双等号（==），比较的是他们的值。 2、引用类型(类、接口、数组)当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个 new 出来的对象，他们的比较后的结果为 true，否则比较后结果为 false。 对象是放在堆中的，栈中存放的是对象的引用（地址）。由此可见 ‘==’ 是对栈中的值进行比较的。如果要比较堆中对象的内容是否相同，那么就要重写 equals 方法了。12345678910111213141516171819202122232425262728293031public static void main(String[] args) &#123; int int1 = 12; int int2 = 12; Integer Integer1 = new Integer(12); Integer Integer2 = new Integer(12); Integer Integer3 = new Integer(127); Integer a1 = 127; Integer b1 = 127; Integer a = 128; Integer b = 128; String s1 = \"str\"; String s2 = \"str\"; String str1 = new String(\"str\"); String str2 = new String(\"str\"); System.out.println(\"int1 == int2: \" + (int1 == int2)); System.out.println(\"int1 == Integer1: \" + (int1 == Integer1)); System.out.println(\"Integer1 == Integer2: \" + (Integer1 == Integer2)); System.out.println(\"Integer3 == b1: \" + (Integer3 == b1)); System.out.println(\"a1 == b1: \" + (a1 == b1)); System.out.println(\"a == b: \" + (a == b)); System.out.println(\"s1 == s2: \" + (s1 == s2)); System.out.println(\"s1 == str1: \" + (s1 == str1)); System.out.println(\"str1 == str2: \" + (str1 == str2)); &#125; 输出结果为：int1 == int2: trueint1 == Integer1: trueInteger1 == Integer2: falseInteger3 == b1: falsea1 == b1: truea == b: falses1 == s2: trues1 == str1: falsestr1 == str2: false equals1、默认情况（没有覆盖 equals 方法）equals 方法都是调用 Object 类的 equals 方法，而 Object 的 equals 方法主要用于判断对象的内存地址引用是不是同一个地址（是不是同一个对象）。下面是 Object 类中 equals 方法：123public boolean equals(Object obj) &#123; return (this == obj);&#125; 定义的 equals 与 == 是等效的。 2、覆盖了 equals 方法类中如果覆盖了 equals 方法，就要根据具体的代码来确定 equals 方法的作用了，覆盖后一般都是通过对象的内容是否相等来判断对象是否相等。下面是String类对equals进行了重写:123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = count; if (n == anotherString.count) &#123; char v1[] = value; char v2[] = anotherString.value; int i = offset; int j = anotherString.offset; while (n-- != 0) &#123; if (v1[i++] != v2[j++]) return false; &#125; return true; &#125; &#125; return false;&#125; 即 String 中 equals 方法判断相等的步骤是： 1、若 A == B，即是同一个String对象，返回 true。 2、若对比对象是 String 类型则继续，否则返回 false。 3、判断 A、B 长度是否一样，不一样的话返回 false。 4、逐个字符比较，若有不相等字符，返回 false。 这里对 equals 重写需要注意五点： 自反性：对任意引用值 X，x.equals(x) 的返回值一定为 true。 对称性：对于任何引用值 x，y，当且仅当 y.equals(x) 返回值为 true 时，x.equals(y) 的返回值一定为 true。 传递性：如果 x.equals(y) = true，y.equals(z) = true，则 x.equals(z) = true。 一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变。 非空性：任何非空的引用值X，x.equals(null) 的返回值一定为 false。 实现高质量 equals 方法的诀窍： 1、使用 == 符号检查“参数是否为这个对象的引用”。如果是，则返回 true。 2、使用 instanceof 操作符检查“参数是否为正确的类型”。如果不是，则返回 false。一般来说，所谓“正确的类型”是指 equals 方法所在的那个类。 3、把参数转换成正确的类型。因为转换之前进行过 instanceof 测试，所以确保会成功。 4、对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配。如果这些测试全部成功，则返回 true；否则返回 false。 5、当编写完成了 equals 方法之后，检查“对称性”、“传递性”、“一致性”。 hashcodehashCode() 方法返回的就是一个数值，从方法的名称上就可以看出，其目的是生成一个 hash 码。hash 码的主要用途就是在对对象进行散列的时候作为 key 输入，据此很容易推断出，我们需要每个对象的 hash 码尽可能不同，这样才能保证散列的存取性能。事实上，Object 类提供的默认实现确实保证每个对象的 hash 码不同（在对象的内存地址基础上经过特定算法返回一个 hash 码）。哈希（Hash）实际上是个人名，由于他提出哈希算法的概念，所以就以他的名字命名了。 哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。 散列函数，散列算法，哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。好的散列函数在输入域中很少出现散列冲突。 所有散列函数都有如下一个基本特性：1、如果 a = b，则 h(a) = h(b)。2、如果 a != b，则 h(a) 与 h(b) 可能得到相同的散列值。 想要明白，必须要先知道Java中的集合。 总的来说，Java中的集合（Collection）有两类，一类是 List，再有一类是 Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。 那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？ 这就是 Object.equals 方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有 1000 个元素，那么第 1001 个元素加入集合时，它就要调用 1000 次 equals 方法。这显然会大大降低效率。 于是，Java 采用了哈希表的原理。这样一来，当集合要添加新的元素时，先调用这个元素的 hashCode 方法，就一下子能定位到它应该放置的物理地址位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的 equals 方法与新元素进行比较，相同的话就不存，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用 equals 方法的次数就大大降低了，几乎只需要一两次。 eqauls 方法和 hashCode 方法的关系Java 对于 eqauls 方法和 hashCode 方法是这样规定的： 1、同一对象上多次调用 hashCode() 方法，总是返回相同的整型值。2、如果 a.equals(b)，则一定有 a.hashCode() 一定等于 b.hashCode()。3、如果 !a.equals(b)，则 a.hashCode() 不一定等于 b.hashCode()。此时如果 a.hashCode() 总是不等于 b.hashCode()，会提高 hashtables 的性能。4、a.hashCode() == b.hashCode() 则 a.equals(b) 可真可假。5、a.hashCode()！= b.hashCode() 则 a.equals(b) 为假。 简而言之：1、如果两个对象 equals，Java 运行时环境会认为他们的 hashcode 一定相等。2、如果两个对象不 equals，他们的 hashcode 有可能相等。3、如果两个对象 hashcode 相等，他们不一定 equals。4、如果两个对象 hashcode 不相等，他们一定不 equals。 关于这两个方法的重要规范：规范 1：若重写 equals(Object obj) 方法，有必要重写 hashcode() 方法，确保通过 equals(Object obj) 方法判断结果为 true 的两个对象具备相等的 hashcode() 返回值。说得简单点就是：“如果两个对象相同，那么他们的hashcode应该相等”。不过请注意：这个只是规范，如果你非要写一个类让 equals(Object obj)返回 true 而 hashcode() 返回两个不相等的值，编译和运行都是不会报错的。不过这样违反了 Java 规范，程序也就埋下了BUG。 规范 2：如果 equals(Object obj) 返回 false，即两个对象“不相同”，并不要求对这两个对象调用 hashcode() 方法得到两个不相同的数。说的简单点就是：“如果两个对象不相同，他们的 hashcode 可能相同”。 为什么重写 equals 方法时总要重写 hashcode 方法一个很常见的错误根源在于没有覆盖 hashCode 方法。在每个覆盖了 equals 方法的类中，也必须覆盖 hashCode 方法。如果不这样做的话，就会违反 Object.hashCode 的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括 HashMap、HashSet 和 Hashtable。 1、在应用程序的执行期间，只要对象的 equals 方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode 方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。 2、如果两个对象根据 equals() 方法比较是相等的，那么调用这两个对象中任意一个对象的 hashCode 方法都必须产生同样的整数结果。 3、如果两个对象根据 equals() 方法比较是不相等的，那么调用这两个对象中任意一个对象的 hashCode 方法，则不一定要产生相同的整数结果。但是如果让不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。 参考资源：http://java-min.iteye.com/blog/1416727https://blog.csdn.net/hla199106/article/details/46907725","categories":[{"name":"Java","slug":"Java","permalink":"https://kevinyangI.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://kevinyangI.github.io/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://kevinyangI.github.io/categories/Java/"}]},{"title":"理解 Integer 和 int 的区别","slug":"理解 Integer 和 int","date":"2018-08-15T02:37:50.000Z","updated":"2018-09-02T08:36:40.303Z","comments":true,"path":"2018/08/15/理解 Integer 和 int/","link":"","permalink":"https://kevinyangI.github.io/kevinyangI.github.io/2018/08/15/理解 Integer 和 int/","excerpt":"","text":"基础类型和封装类型的区别1、传递方式不同封装类是引用类型，基本类型（原始数据类型）在传递参数时都是按值传递，而封装类型是按引用传递的(其实“引用也是按值传递的”，传递的是对象的地址)。由于引用类型都是不可变量，因此没有提供改变它的值的方法，增加了对“按引用传递”的理解难度。int 是基本类型，直接存放数值；Integer 是类，产生对象时用一个引用指向这个对象。 2、封装类可以有方法和属性封装类可以有方法和属性，利用这些方法和属性来处理数据，如 Integer.parseInt(Strings)。基本数据类型都是 final 修饰的，不能继承扩展新的类、新的方法。 3、默认值不同基本类型跟封装类型的默认值是不一样的。如 int i，i 的预设为 0；Integer j，j 的预设为 null，因为封装类产生的是对象，对象默认值为 null。 4、存储位置不同基本类型在内存中是存储在栈中，引用类型的引用（值的地址）存储在栈中，而实际的对象（值）是存在堆中。 Integer 和 int 的区别 1、Integer 是 int 的包装类，而 int 是一种基本数据类型。2、Integer 变量必须实例化后才能使用，而 int 变量不需要。3、Integer 实际是对象的引用，当 new 一个 Integer 时，实际上是生成一个指针指向此对象；而 int 则是直接存储数据值。4、Integer 的默认值是 null，int 的默认值是 0。 Integer 和 int 的比较比较两个 new 出来的 Integer1234567891011/** * 比较两个 new 出来的 Integer */public class Test &#123; public static void main(String[] args) &#123; Integer i = new Integer(200); Integer j = new Integer(200); System.out.print(i == j); //输出：false &#125;&#125; Integer 变量实际上是对一个 Integer 对象的引用。当 new 一个 Integer 时，实际上是生成一个指针指向此对象，两次 new Integer 生成的是两个对象，其内存地址不同，所以两个 new 出来的 Integer 变量不相等。 比较非 new 生成的 Integer 变量与 new 生成的 Integer 变量1234567891011/** * 比较非 new 生成的 Integer 变量与 new 生成的 Integer 变量 */public class Test &#123; public static void main(String[] args) &#123; Integer i = new Integer(200); Integer j = 200; System.out.print(i == j); //输出：false &#125;&#125; 因为非 new 生成的 Integer 变量指向的是 java 常量池中的对象，而 new Integer() 生成的变量指向堆中新建的对象，两者在内存中的地址不同，所以输出为 false。 比较两个非 new 生成的 Integer 变量12345678910111213/** * 比较两个非 new 生成的 Integer 变量 */public class Test &#123; public static void main(String[] args) &#123; Integer i1 = 127; Integer j1 = 127; System.out.println(i1 == j1); //输出：true Integer i2 = 128; Integer j2 = 128; System.out.println(i2 == j2); //输出：false &#125;&#125; java 在编译 Integer i1 = 127 时，会翻译成 Integer i1 = Integer.valueOf(127)，查看Interger源码：12345678/* This method will always cache values in the range -128 to 127, * inclusive, and may cache other values outside of this range. */public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 可以看出，java 会将 [-128,127] 之间的数进行缓存。Integer i1 = 127 时，会将 127 缓存，Integer j2 = 127 时，就直接从缓存中取，不会 new 了，所以结果为 true。 Integer i2 = 128 时，不会将 128 缓存，Integer j2 = 128 时，会 return new Integer(128)，所以结果为 false。 比较 Integer 变量与 int 变量123456789101112/** * 比较 Integer 变量与 int 变量 */public class Test &#123; public static void main(String[] args) &#123; Integer i1 = 200; Integer i2 = new Integer(200); int j = 200; System.out.println(i1 == j); //输出：true System.out.println(i2 == j); //输出：true &#125;&#125; 包装类 Integer 变量在与基本数据类型 int 变量比较时，Integer 会自动拆包装为 int，然后进行比较，实际上就是两个 int 变量进行比较，值相等，所以为 true。","categories":[{"name":"Java","slug":"Java","permalink":"https://kevinyangI.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://kevinyangI.github.io/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://kevinyangI.github.io/categories/Java/"}]},{"title":"理解 Java 的多态","slug":"理解 Java 的多态","date":"2018-08-14T02:37:50.000Z","updated":"2018-08-31T14:21:45.740Z","comments":true,"path":"2018/08/14/理解 Java 的多态/","link":"","permalink":"https://kevinyangI.github.io/kevinyangI.github.io/2018/08/14/理解 Java 的多态/","excerpt":"","text":"多态的概念 多态的定义：指允许不同类的对象对同一函数调用做出响应，即同一函数调用可以根据发送对象的不同而采用多种不同的行为方式。 实现多态的技术：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际类型调用相对应的方法。 多态的作用：消除类型之间的耦合关系。 Java实现多态有三个必要条件：继承、重写、向上转型。 继承：在多态中必须存在有继承关系的子类和父类。 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。 向上转型：在多态中需要将父类引用指向子类对象，才能够调用父类和子类中的方法。 最终多态体现为父类引用指向子类对象：父类类型 变量名 = new 子类类型()。 多态的三种形式1. 普通类多态定义的格式：父类 变量名 = new 子类();123456789class Parent &#123; &#125;class Child extends Parent &#123; &#125;//接口的多态使用Parent parent = new Child(); 2. 抽象类多态定义的格式：抽象类 变量名 = new 子类();1234567891011abstract class Parent &#123; public abstract void method();&#125;class Child extends Parent &#123; public void method()&#123; System.out.println(“重写接口抽象方法”); &#125;&#125;//接口的多态使用Parent parent = new Child(); 3. 接口多态定义的格式：接口 变量名 = new 子类();1234567891011interface Parent &#123; public abstract void method();&#125;class Child implements Parent &#123; public void method()&#123; System.out.println(“重写接口抽象方法”); &#125;&#125;//接口的多态使用Parent parent = new Child(); 多态实例分析实例一 成员变量12345678910111213141516class Parent &#123; int num = 4; //没有这句会提示编译失败&#125;class Child extends Parent &#123; int num = 5;&#125;class Demo &#123; public static void main(String[] args) &#123; Parent parent = new Child(); System.out.println(parent.num); Child child = new Child(); System.out.println(child.num); &#125;&#125; 打印结果：4 5总结：当子父类中出现同名的成员变量时，多态调用该变量时：1、编译时期：参考的是引用型变量所属的类中是否有被调用的成员变量，若没有，编译失败。2、运行时期：也是调用引用型变量所属的类中的成员变量。简而言之：编译和运行都参考等号的左边，编译运行看左边。 实例二 成员方法1234567891011121314151617181920212223242526class Parent &#123; int num = 4; //没有这个方法，编译失败 void show() &#123; System.out.println(\"Parent show num\"); &#125;&#125;class Child extends Parent &#123; int num = 5; //重写父类方法 void show() &#123; System.out.println(\"Child show num\"); &#125; void show_1&#123; System.out.println(\"Child show show_1\"); &#125;&#125;class Demo &#123; public static void main(String[] args) &#123; Parent parent = new Child(); parent.show(); //parent.show_1(); &#125;&#125; 打印结果：Child show num总结：多态成员方法1、编译时期：参考引用变量所属的类，如果没有类中没有调用的方法，编译失败（如果把 parent.show_1() 前面的注释打开，则编译失败）。2、运行时期：参考引用变量所指的对象所属的类，并运行对象所属类中的成员方法（如果把子类重写的 show() 方法注释掉，那么打印的结果是 Parent show num）。简而言之：编译看左边，运行看右边。 实例三 综合运用123456789101112131415161718192021222324252627282930313233343536373839404142class A &#123; public String show(D obj)&#123; //方法一 return (\"A and D\"); &#125; public String show(A obj)&#123; //方法二 return (\"A and A\"); &#125;&#125;class B extends A&#123; public String show(B obj)&#123; //方法三 return (\"B and B\"); &#125; public String show(A obj)&#123; //方法四 return (\"B and A\"); &#125;&#125;class C extends B&#123;&#125;class D extends B&#123;&#125;public class Test1 &#123; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println(\"1--\" + a1.show(b)); System.out.println(\"2--\" + a1.show(c)); System.out.println(\"3--\" + a1.show(d)); System.out.println(\"4--\" + a2.show(b)); System.out.println(\"5--\" + a2.show(c)); System.out.println(\"6--\" + a2.show(d)); System.out.println(\"7--\" + b.show(b)); System.out.println(\"8--\" + b.show(c)); System.out.println(\"9--\" + b.show(d)); &#125;&#125; 那我们开始分析输出 A a1 = new A()，这是普通的创建对象，故 a1 拥有调用方法一和方法二的能力。那么究竟调用哪个方法呢？这里面涉及方法的重载。其实，在编译的时候，编译器已经进行了前期绑定，也就是说，在编译时，系统就已经知道应该调用哪个方法，即使你有方法的重载。 故 a1.show(b) 会与方法二绑定，a1.show(c) 会与方法二绑定，a1.show(d) 会与方法一绑定，且都在编译时完成绑定。 但 A a2 = new B()，就涉及多态了，B 实现了向上转型，创建了一个父类引用，指向子类对象。这样的做法很常见，因为这样不仅增加了灵活性（父类引用可以随时指向任意子类对象），也提高了扩展性。但要知道的是，向上转型的缺点，就是不能调用子类中特有而父类中没有的方法。 故 A a2 = new B() 中，方法四对方法二进行了重写，所以 a2 拥有调用方法一和方法四的能力，而方法三不能调用。所以，在编译时， a2.show(b) 会与方法四绑定；a2.show(c) 会与方法四绑定；a2.show(d) 会与方法一绑定。 B b = new B()，这是普通的创建子类对象，B 继承于 A，且方法四重写了方法二，所以 b 拥有调用方法一、方法三、方法四的能力。所以 b.show(b) 会与方法三绑定，b.show(c) 会与方法三绑定，b.show(d) 会与方法一绑定。 所以，打印结果是 1--A and A 2--A and A 3--A and D 4--B and A 5--B and A 6--A and D 7--B and B 8--B and B 9--A and D","categories":[{"name":"Java","slug":"Java","permalink":"https://kevinyangI.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://kevinyangI.github.io/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://kevinyangI.github.io/categories/Java/"}]},{"title":"单例模式","slug":"单例模式","date":"2018-08-10T02:37:50.000Z","updated":"2018-08-31T14:32:21.026Z","comments":true,"path":"2018/08/10/单例模式/","link":"","permalink":"https://kevinyangI.github.io/kevinyangI.github.io/2018/08/10/单例模式/","excerpt":"","text":"在所有的设计模式中，单例模式是我们在项目开发中最为常见的设计模式之一，而单例模式有很多种实现方式，你是否都了解呢？高并发下如何保证单例模式的线程安全性呢？如何保证序列化后的单例对象在反序列化后仍然是单例的呢？ 单例模式定义 定义：确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 基本原理：将构造函数私有化，并且通过静态方法或枚举获取一个唯一的实例对象，在这个获取的过程中必须保证线程安全、防止反序列化导致重新生成实例对象等问题。 适用场景： 需要频繁地进行创建和销毁的对象； 创建对象时耗时过多或耗费资源过多，但又经常用到的对象； 工具类对象； 频繁访问数据库或文件的对象。 通过单例类的构造函数私有化，使得客户端代码不能通过 new 的形式手动构造单例类的对象。单例类会暴露一个公有静态方法，客户端需要调用这个静态方法获取到单例类的唯一实例，在获取这个单例对象的过程中需要确保线程安全，即在多线程环境下构造单例类的对象也是有且只有一个，这也是单例模式实现中比较困难的地方。 饿汉式（静态常量）[可用]12345678910public class Singleton &#123; private final static Singleton instance = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 优点：这种写法比较简单，就是在类装载的时候就完成实例化，避免了线程同步问题。 缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果，如果从始至终从未使用过这个实例，则会造成内存的浪费。 饿汉式（静态代码块）[可用]1234567891011121314public class Singleton &#123; private static Singleton instance; static &#123; instance = new Singleton(); &#125; private Singleton() &#123;&#125; public Singleton getInstance() &#123; return instance; &#125;&#125; 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。 优点：在类装载的时候就完成实例化，避免了线程同步问题。 缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果，如果从始至终从未使用过这个实例，则会造成内存的浪费。 懒汉式（线程不安全）[不可用]12345678910111213public class Singleton &#123; private static Singleton singleton; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 懒汉式单例是指在方法调用获取实例时才创建实例，因为相对饿汉式显得“不那么急迫”，所以被叫做“懒汉模式”。这种写法虽然起到了 Lazy Loading 的效果，但是只能在单线程下使用。在多线程并发下这样的实现是无法保证实例是唯一的，甚至可以说这样的失效是完全错误的。比如，一个线程进入了 if (singleton == null) 判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种实现方式。 懒汉式（线程安全，同步方法）[不推荐用]12345678910111213public class Singleton &#123; private static Singleton singleton; private Singleton() &#123;&#125; public static synchronized Singleton getInstance() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 解决上面第三种实现方式的线程不安全问题，做个线程同步就可以了，于是就对 getInstance() 方法进行了线程同步。 缺点：效率太低了，每个线程在想获得类的实例的时候，执行 getInstance() 方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了，方法进行同步效率太低需要改进。 懒汉式（线程安全，同步代码块）[不可用]123456789101112131415public class Singleton &#123; private static Singleton singleton; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; singleton = new Singleton(); &#125; &#125; return singleton; &#125;&#125; 由于第四种实现方式同步效率太低，所以摒弃同步方法，改为同步产生实例化的的代码块。但是这种同步并不能起到线程同步的作用。跟第三种实现方式遇到的情形一致，假如一个线程进入了 if (singleton == null) 判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。 双重检查（线程安全）[推荐用]123456789101112131415161718public class Singleton &#123; //使用 volatile 关键字保其可见性 private static volatile Singleton singleton; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; Double-Check-Locking DCL 双检查锁机制对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次 if (singleton == null) 检查，这样就可以保证线程安全了。这样，实例化代码只会执行一次，后面再次访问时，判断 if (singleton == null) ，直接 return 实例化对象。 优点：线程安全、延迟加载、效率较高。 静态内部类（线程安全）[推荐用]123456789101112public class Singleton &#123; private Singleton() &#123;&#125; private static class SingletonInstance &#123; private static final Singleton singleton = new Singleton(); &#125; public static Singleton getInstance() &#123; return SingletonInstance.singleton; &#125;&#125; 这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要 Singleton 类被装载就会实例化，没有 Lazy-Loading 的作用，而静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。 优点：避免了线程不安全，延迟加载，效率高。 序列化与反序列化（线程安全）[推荐用]静态内部类虽然保证了单例在多线程并发下的线程安全性，但是在遇到序列化对象时，默认的方式运行得到的结果却是多例的。 1234567891011121314151617181920212223import java.io.ObjectStreamException;import java.io.Serializable; public class Singleton implements Serializable &#123; private static final long serialVersionUID = 1L; //内部类 private static class SingletonInstance&#123; private static Singleton instance = new Singleton(); &#125; private Singleton()&#123;&#125; public static Singleton getInstance() &#123; return SingletonInstance.instance; &#125; //该方法在反序列化时会被调用，该方法不是接口定义的方法，有点儿约定俗成的感觉 protected Object readResolve() throws ObjectStreamException &#123; return SingletonInstance.instance; &#125;&#125; 添加 readResolve 方法后，反序列化得到的实例和序列化前的实例是同一个实例，单个实例得到了保证。 枚举（线程安全）[推荐]枚举 enum 和静态代码块的特性相似，在使用枚举时，构造方法会被自动调用，利用这一特性也可以实现单例。 1234567891011121314151617public enum EnumFactory&#123; singletonFactory; private Singleton instance; private EnumFactory()&#123; //枚举类的构造方法在类加载时被实例化 instance = new Singleton(); &#125; public Singleton getInstance()&#123; return instance; &#125;&#125;class Singleton&#123; //需要获实现单例的类 public Singleton()&#123;&#125; &#125; 这样写单例虽然得到了保证，但是枚举类具体实现被完全暴露了，下面是内部枚举类的实现。 123456789101112131415161718192021222324public class ClassFactory&#123; private enum EnumSingleton&#123; singletonFactory; private Singleton instance; private EnumSingleton()&#123; //枚举类的构造方法在类加载时被实例化 instance = new Singleton(); &#125; public Singleton getInstance()&#123; return instance; &#125; &#125; public static Singleton getInstance()&#123; return EnumSingleton.singletonFactory.getInstance(); &#125;&#125; class Singleton&#123; //需要获实现单例的类 public Singleton()&#123;&#125; &#125; 总结单例模式是运用频率很高的模式，但是，由于在客户端通常没有高并发的情况，因此，选择哪种实现方式并不会有太大的影响。即便如此，出于效率考虑，推荐使用双检查锁机制和静态内部类实现的方式。 优点: 由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。 由于单例模式只生成一个实例，所以，减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决。 单例模式可以避免对资源的多重占用，例如一个写文件操作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。 单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如，可以设计一个单例类，负责所有数据表的映射处理。 缺点： 单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。 单例对象如果持有 Context，那么很容易引发内存泄漏，此时需要注意传递给单例对象的 Context 最好是 Application Context。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://kevinyangI.github.io/categories/设计模式/"}],"tags":[{"name":"单例模式","slug":"单例模式","permalink":"https://kevinyangI.github.io/tags/单例模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"https://kevinyangI.github.io/categories/设计模式/"}]},{"title":"工作中如何做好技术积累","slug":"工作中如何做好技术积累","date":"2018-07-23T03:58:55.000Z","updated":"2018-07-24T02:04:16.629Z","comments":true,"path":"2018/07/23/工作中如何做好技术积累/","link":"","permalink":"https://kevinyangI.github.io/kevinyangI.github.io/2018/07/23/工作中如何做好技术积累/","excerpt":"本文来自美团点评技术团队： 工作中如何做好技术积累 引言古人云：“活到老，学到老。”互联网算是最辛苦的行业之一，“加班”对工程师来说已是“家常便饭”，同时互联网技术又日新月异，很多工程师都疲于应付，叫苦不堪。以至于长期以来流传一个很广的误解：35岁是程序员工作的终点。 如何在繁忙的工作中做好技术积累，构建个人核心竞争力，相信是很多工程师同行都在思考的问题。本文是我自己的一些总结，试图从三个方面来解答： 第一部分阐述了一些学习的原则。任何时候，遵循一些经过检验的原则，都是影响效率的重要因素，正确的方法是成功的秘诀。 提升工作和学习效率的另一个重要因素是释惑和良好心态。第二部分分析了我在工作中碰到和看到的一些典型困惑。 成为优秀的架构师是大部分初中级工程师的阶段性目标。第三部分剖析架构师的能力模型，让大家对目标所需能力有一个比较清晰的认知。","text":"本文来自美团点评技术团队： 工作中如何做好技术积累 引言古人云：“活到老，学到老。”互联网算是最辛苦的行业之一，“加班”对工程师来说已是“家常便饭”，同时互联网技术又日新月异，很多工程师都疲于应付，叫苦不堪。以至于长期以来流传一个很广的误解：35岁是程序员工作的终点。 如何在繁忙的工作中做好技术积累，构建个人核心竞争力，相信是很多工程师同行都在思考的问题。本文是我自己的一些总结，试图从三个方面来解答： 第一部分阐述了一些学习的原则。任何时候，遵循一些经过检验的原则，都是影响效率的重要因素，正确的方法是成功的秘诀。 提升工作和学习效率的另一个重要因素是释惑和良好心态。第二部分分析了我在工作中碰到和看到的一些典型困惑。 成为优秀的架构师是大部分初中级工程师的阶段性目标。第三部分剖析架构师的能力模型，让大家对目标所需能力有一个比较清晰的认知。 如何学习在繁忙的工作中，持之以恒、不断学习和进步是一件艰巨的任务，需要坚强的毅力和坚定的决心。如果方法不得当，更是事倍功半。幸好我们的古人和现在哲人已经总结了很多优秀的学习方法论，这里汇总了一些重要原则。遵循这些方法必会对大家的工作学习大有裨益。 贵在坚持有报道指出，过去几十年的知识量超过之前人类几千年的知识量总和。而计算机领域绝对是当代知识更新最快的领域之一，因此，工程师必须要接受这样一个现实，现在所掌握的深厚知识体系很快就会被淘汰。要想在计算机领域持续做优秀架构师，就必须不停的学习，掌握最新技术。总之，学不可以已。 所谓“冰冻三尺，非一日之寒，水滴石穿，非一日之功”，通往架构师的道路漫长而又艰巨，轻易放弃，则所有付出瞬间付之东流。要想成为优秀的架构师，贵在坚持！ 虽然知识更新很快，但是基础理论的变化却非常缓慢。这就是“道”和“象”关系，纵是世间万象，道却万变不离其宗。对于那些非常基础的理论知识，我们需要经常复习，也就是“学而时习之”。 重视实践古人云：“纸上得来终觉浅，绝知此事要躬行。” 学习领域有所谓721模型：个人的成长70%来自于岗位实践，20%来自向他人学习，10%来自于培训。虽然这种理论存在争议，但对于工程师们来说，按照实践、学习和培训的方式进行重要性排序，大致是不错的。所以重视实践，在实践中成长是最重要的学习原则。 人类的认知有两种：感性认知和理性认知。这两种认知互相不可替代性。实践很大程度来自于感性学习，看书更像是理性学习。以学开汽车做例子，很难想象什么人能够仅仅通过学习书本知识就会开汽车。 书本知识主要是传道——讲述抽象原型，而对其具体应用场景的讲述往往含糊其辞，对抽象原型之间的关系也是浅尝辄止。采用同样精确的语言去描述应用场景和关联关系将会失去重点，让人摸不着头脑。所以，仅仅通过看书来获得成长就像是用一条腿走路。 重视实践，充分运用感性认知潜能，在项目中磨炼自己，才是正确的学习之道。在实践中，在某些关键动作上刻意练习，也会取得事半功倍的效果。 重视交流牛顿说：“如果说我看得比别人远一些，那是因为我站在巨人的肩膀上。”我们需要从别人身上学习。从老师、领导、同事、下属甚至对手身上学习，是快速成长的重要手段。 向老师和领导学习已经是人们生活习惯的一部分了。但是从同事甚至对手那里学习也很重要，因为这些人和我们自身更相似。所以要多多观察，取其所长，弃其所短。对于团队的小兄弟和下属，也要“不耻下问”。 此外，在项目中积极参与具体方案讨论也非常重要。参与者先验感知了相关背景，并且讨论的观点和建议也是综合了发言者多种知识和技能。所以，讨论让参与者能够非常全面，立体地理解书本知识。同时，和高手讨论，他们的观点就会像修剪机剪树枝一样，快速的剪掉自己知识领域里面的疑惑点。 重视总结和输出工程师在实践中会掌握大量细节，但是，即使掌握了所有细节，却没有深刻的总结和思考，也会陷入到“学而不思则罔”的境地。成长的“量变”来自于对细节的逐渐深入地把控，而真正的“质变”来自于对“道”的更深层次的理解。 将经验输出，接受别人的检验是高层次的总结。这种输出不仅帮助了别人，对自身更是大有裨益。总结的方式有很多，包括组织分享，撰写技术文章等等。当然“日三省吾身”也是不错的总结方式。总之，多多总结，多多分享，善莫大焉！ 解答别人的问题也是个人成长的重要手段。有时候，某个问题自己本来不太懂，但是在给别人讲解的时候却豁然开朗。所以，“诲人不倦”利人惠己。 重视规划凡事预则立，不预则废。对于漫长的学习生涯而言，好的计划是成功的一半。 长期规划 长期规划的实施需要毅力和决心，但是做正确的长期规划还需要高瞻远瞩的眼界、超级敏感的神经和中大奖的运气。对于大部分人来说，长期规划定主要是“定方向”。但遵循如下原则能够减少犯方向性错误的概率： 远离日暮西山的行业。 做自己感兴趣的事情。 做有积累的事情。 一边走一边看，切勿一条道走到黑。 短期规划 良好的短期规划应该在生活、成长、绩效和晋升之间取得平衡。大部分公司都会制定一个考核周期——少则一个月，多则一年。所以不妨以考核周期作为短期学习规划周期。本质上，规划是一个多目标优化问题，它有一系列的理论方案，这里不一一细说。基于相关理论，我给出一个简单易行的方案： 确定目标优先级。比如：成长、生活、绩效。 确定每个目标的下限。从优化理论的角度来看，这被称为约束。比如绩效必须在一般以上，之前已经规划好的旅行不能更改，必须读完《Effective Java》等等。 优先为下限目标分配足够的资源。比如，事先规划好的旅行需要10天，这10天就必须预算出去。 按照各主目标的顺序依次分配资源。比如，最终分配给学习的时间是10天。 在给定的学习预算下，制定学习目标，要激进。然后给出执行方案。比如，学习目标是掌握基本的统计学知识，并成为Java专家。具体方案为：完成《Effective Java》、《Java Performance》、《Design Pattern》、《Head First Statistics》四本书的阅读。 对规划中的各学习任务按目标优先级进行排序，并最先启动优先级最高的任务。比如，最高优先级是掌握统计理论，那么就要先看《Head First Statistics》。 对于该方案，要注意以下几点： 最低目标必须能够轻松达成的目标，否则，从优化理论的角度来讲，该命题无解。比如，类似“半年内完成晋级两次、绩效全部S、从菜鸟成为Java专家”就不太合适作为最低目标。总之，要区分理想和梦想。 主要目标规划必须具备一定的挑战性，需要规划出不可能完成的目标。过度规划本质上是一种贪婪算法，目的是目标价值最大化。因为一切皆有变数，如果其他目标能够提前完成，就不妨利用这些时间去完成更多的学习目标。总之，前途必须光明，道路必须坎坷。 各目标之间不一定共享资源，规划不一定互有冲突。 此外，短期规划还可以从如下几个方面进行优化： 学习计划最好能结合工作计划，理论联系实际结合，快速学以致用。比如，本季度规划去做一些数据分析工作，那么不妨把学习目标设置为学习统计知识。 要灵活对待规划的目标和具体执行步骤，需要避免“郑人买履”式的笑话。面临新的挑战和变化，规划需要不断地调整。 那些令人纠结的困惑人生是一场马拉松，在漫长的征途中，难免有很多困惑。困惑就像枷锁，使我们步履蹒跚，困惑就像死锁，让我们停滞不前。 接下来我将总结自己在工作中碰到和看到的一些典型困惑。这些困惑或者长期困扰作者本人，或者困扰我身边的同事和朋友。当这些困惑被释然之后，大家都感觉如重获释，为下一阶段的征程提供满满的正能量。人生就像一场旅途，不必在乎目的地，在乎的，应该是沿途的风景，以及看风景的心情。良好的心态是技术之旅最好的伴侣。期望通过这个解惑之旅，让大家拥有一个愉快的心情去感受漫长的学习旅途。 学无止境吗必须要承认一个残酷的现实：人的生命是有限的，知识却是无限的。用有限的生命去学习无限的知识是不可能完成的任务。一想到此，有些工程师不免产生一些悲观情绪。如果方法得当并且足够勤奋，悲伤大可不必。 虽然，人类的整体知识体系一直在扩张。但是就很多重要的工程细分领域，基础理论并不高深。计算机的很多重要领域，工程师有能力在有限时间内抓住核心要害。 比如，密码学被认为是门非常高深的学科，但是一大类密码技术的基础是数论中一个非常简单的理论——素因数分解：给出两个素数，很容易算出它们的积，然而反过来给定两个素数的积，分解的计算量却非常惊人。 “一致性”算得上是计算机领域里面最经典的难题，它是所有分布式系统的基础，从多核多CPU到多线程，从跨机器到跨机房，无所不在，几乎所有的计算机从业人员都在解决这个问题，但是Paxos给出了一个很优雅的解决方案。 权限管理是很多工程师的噩梦，但如果你能搞定“Attribute Based Access Control(ABAC)”和“Role-Based Access Control(RBAC)”，也能达到相当高度。 另外，技术学习是一场对抗赛，虽然学无止境，超越大部分对手就是一种胜利。所以，以正确的学习方式，长时间投入就会形成核心竞争力。 没有绝对高明的技术只有真正的高手致力于在技术上有所成就的工程师，都梦想有朝一日成为技术高手。但技术高手的标准却存在很大的争议。这是一个有着悠久历史的误解：以某种技术的掌握作为技术高手的评判标准。我经常碰到这样一些情景：因为掌握了某些技术，比如Spring、Kafka、Elasticsearch等，一些工程师就自封为高手。有些工程师非常仰慕别的团队，原因竟是那个团队使用了某种技术。 这种误解的产生有几个原因：首先，技多不压身，技术自然是掌握的越多越好，掌握很多技术的人自然不是菜鸟。其次，在互联网时代来临之前，信息获取是非常昂贵的事情。这就导致一项技能的掌握可以给个人甚至整个公司带来优势地位。互联网时代，各种框架的出现以及开源的普及快速淘汰或者降低了很多技能的价值，同时降低了很多技术的学习门槛。所以，在当前，掌握某项技能知识只能是一个短期目标。怀揣某些技能就沾沾自喜的人需要记住：骄傲使人退步。 所谓麻雀虽小，五脏俱全。如果让你来做造物主，设计麻雀和设计大象的复杂度并没有明显区别。一个看起来很小的业务需求，为了达到极致，所需要的技术和能力是非常综合和高深的。真正的高手不是拿着所掌握的技术去卡客户需求，而是倾听客户的需求，给出精益求精的方案。完成客户的需求是一场擂台赛，真正的高手，是会见招拆招的。 不做项目就无法成长吗在项目中学习是最快的成长方式之一，很多工程师非常享受这个过程。但是一年到头都做项目，你可能是在一家外包公司。对于一个做产品的公司，如果年头到年尾都在做项目，要不然就是在初步创业阶段，要不然就是做了大量失败的项目，总之不算是特别理想的状态。正常情况，在项目之间都会有一些非项目时间。在这段时间，有些同学会产生迷茫，成长很慢。 项目真的是越多越好吗？答案显然是否定的。重复的项目不会给工程师们带来新的成长。不停的做项目，从而缺乏学习新知识的时间，会导致“做而不学则殆”。真正让工程师出类拔萃的是项目的深度，而不是不停地做项目。所以，在项目之间的空档期，工程师们应该珍惜难得的喘息之机，深入思考，把项目做深，做精。 如何提高项目的深度呢？一般而言，任何项目都有一个目标，当项目完成后，目标就算基本达成了。但是，客户真的满意了吗？系统的可用性、可靠性、可扩展性、可维护性已经做到极致了吗？这几个问题的答案永远是否定的。所以，任何一个有价值的项目，都可以一直深挖。深挖项目，深度思考还可以锻炼工程师的创造力。期望不停地做项目的人，就像一个致力于训练更多千里马的人是发明不出汽车的。锻炼创造力也不是一蹴而就的事情，需要长时间地思考。总之，工程师们应该总是觉得时间不够用，毕竟时间是最宝贵的资源。 职责真的很小吗很多时候，一个工程师所负责系统的数量和团队规模与其“江湖地位”正相关。但是，江湖地位与技术成长没有必然关联。提升技术能力的关键是项目深度以及客户的挑剔程度。项目越多，在单个项目中投入的时间就越少，容易陷入肤浅。特别需要避免的是“ 在其位不谋其政”的情况。团队越大，在管理方面需要投入的精力就越多。在管理技巧不成熟，技术眼界不够高的前提强行负责大团队，可能会导致个人疲于应付，团队毫无建树。最终“ 一将无能，累死三军”，效果可能适得其反。 从技术发展的角度来说，技术管理者应该关注自己所能把控的活跃项目的数量，并致力于提高活跃项目的影响力和技术深度。团队人数要与个人管理能力、规划能力和需求把控能力相适应。一份工作让多个人来干，每个人的成长都受限。每个人都做简单重复的工作，对技术成长没有任何好处。团队管理和项目管理需要循序渐进，忌“拔苗助长”。 一定要当老大吗有一些工程师的人生理想是做团队里的技术老大，这当然是一个值得称赞的理想。可是，如果整个团队技术能力一般，发展潜力一般，而你是技术最强者，这与其说是幸运，不如说是悲哀。这种场景被称之为“武大郎开店”。 团队里的技术顶尖高手不是不能做，但为了能够持续成长，需要满足如下几个条件： 首先你得是行业里面的顶尖专家了——实在很难找到比你更强的人了！ 其次，你经常需要承担对你自己的能力有挑战的任务，但同时你拥有一批聪明能干的队友。虽然你的技术能力最高，但是在你不熟悉的领域，你的队友能够进行探索并扩展整个团队的知识。 最后，你必须要敏而好学，不耻下问。 否则，加入更强的技术团队或许是更好的选择，最少不是什么值得骄傲的事情。 平台化的传说平台化算得上是“高大上”的代名词了，很多工程师挤破头就为了和“平台化”沾点边。然而和其他业务需求相比，平台化需求并没有本质上的区别。无论是平台化需求还是普通业务需求，它的价值都来自于客户价值。不同点如下： 很多平台化需求的客户来自于技术团队，普通需求的客户来自于业务方。 产品经理不同。普通业务需求来自于产品经理，平台化需求的产品经理可能就是工程师自己。长期被产品经理“压迫”的工程师们，在平台化上终于找到“翻身农奴把歌唱”的感觉。 很多平台化的关注点是接入能力和可扩展性，而普通业务的关注点更多。 归根结底，平台化就是一种普通需求。在实施平台化之前，一定要避免下面两个误区： 平台化绝对不是诸如“统一”、“全面”之类形容词的堆砌。是否需要平台化，应该综合考虑：客户数量，为客户解决的问题，以及客户价值是否值得平台化的投入。 平台化不是你做平台，让客户来服务你。一些平台化设计者的规划设计里面，把大量的平台接入工作、脏活累活交给了客户，然后自己专注于所谓“最高大上”的功能。恰恰相反，平台化应该是客户什么都不做，所有的脏活累活都由平台方来做。本质上讲，平台化的价值来自于技术深度。真正体现技术深度的恰恰是设计者能够很轻松的把所有的脏活累活搞定。 所以平台化的最佳实践是：投入最少的资源，解决最多的问题。平台解决一切，客户坐享其成。 搞基础技术就一定很牛吗经常听到同学们表达对基础技术部同学的敬仰之情，而对搞业务技术的同学表现出很轻视，认为存储、消息队列、服务治理框架（比如美团点评内部使用的OCTO）、Hadoop等才能被称为真正的技术。事实并非如此，更基础的并不一定更高深。 比如下面这个流传很久的段子：越高级的语言就越没有技术含量。但真是这样吗，就拿Java和C来说，这是完全不同的两种语言，所需要的技能完全不同。C或许跟操作系统更加接近一点，和CPU、内存打交道的机会更多一点。但是为了用好Java，程序员在面向对象、设计模式、框架技术方面必须要非常精通。Java工程师转到C方向确实不容易，但作者也见过很多转到Java语言的C工程师水土不服。 基础技术和业务应用技术必然会有不同的关注点，没有高低之分。之所以产生这种误解，有两个原因： 基础技术相对成熟，有比较完整的体系，这给人一个高大上的感觉。业务应用技术相对来说，由于每个团队使用的不一样，所以成熟度参差不齐，影响力没有那么大。 基础技术的门槛相对来说高一点，考虑到影响面，对可靠性、可用性等有比较高的最低要求。但是门槛高不代表技术含量高，另外成熟技术相对来说在创新方面会受到很大的约束。但是最先进的技术都来自活跃的创新。 对比下来，业务技术和基础技术各有千秋。但真正的高手关注的是解决问题，所有的技术都是技能而已。 可行性调研的那些坑工作中开展可行性调研时有发生。做可行性调研要避免如下情况： 把可行性调研做成不可行性调研。这真的非常糟糕。不可行性的结论往往是：因为这样或者那样的原因，所以不可行。 避免“老鼠给猫挂铃铛”式的高风险可行性方案。“天下大事必作于细”，可行性调研一定要细致入微，避免粗枝大叶。 避免调研时间过长。如果发现调研进展进入到指数级复杂度，也就是每前进一步需要之前两倍的时间投入，就应该果断的停止调研。 可行性调研的结论应该是收益与成本的折衷，格式一般如下： 首先明确预期的结果，并按照高中低收益进行分级。 阐述达成每种预期结果需要采取的措施和方案。 给出实施各方案需要付出的成本。 工程师天生不善沟通吗实际工作中，沟通所导致的问题层出不穷。工程师有不少是比较内向的，总是被贴上“不善沟通”的标签。实际上，沟通能力是工程师最重要的能力之一，良好的沟通是高效工作学习的基础，也是通过学习可以掌握的。下面我按工程师的语言说说沟通方面的经验。 第一类常见的问题是沟通的可靠性。从可靠性的角度来讲，沟通分为TCP模式和UDP模式。TCP模式的形象表述是：我知道你知道。UDP模式的形象表述是：希望你知道。TCP模式当然比较可靠，不过成本比较高，UDP模式成本低，但是不可靠。在沟通可靠性方面，常见错误有如下两种： 经常听到的这样的争论。一方说：“我已经告诉他了”，另一方说：“我不知道这个事情呀”。把UDP模式被当作TCP模式来使用容易产生扯皮。 过度沟通。有些同学对沟通的可靠性产生了过度焦虑，不断的重复讨论已有结论问题。把TCP模式当成UDP来使用，效率会比较低。 第二类沟通问题是时效性问题。从时效性讲，沟通分为：同步模式和异步模式。同步沟通形象地说就是：你现在给我听好了。异步沟通的形象表述是：记得给我做好了。在沟通时效性方面，有如下两种常见错误： 已经出现线上事故，紧急万分。大家你一言，我一语，感觉事故可能和某几个人有关，但是也不能完全确定，所以没有通知相关人员。最终，一个普通的事故变成了严重事故。对于紧急的事情，必须要同步沟通。 半夜三点你正在熟睡，或者周末正在逛街，接到一个电话：“现在有个需求，能否立刻帮忙做完。”这会非常令人郁闷，因为那并不是紧急的事情。不是所有的需求都需要立刻解决。 有效沟通的一个重要原则是提前沟通。沟通本质是信息交流和处理，可以把被沟通对象形象地比喻成串行信息处理的CPU。提前沟通，意味着将处理请求尽早放入处理队列里面。下面的例子让很多工程师深恶痛绝：一个需求策划了1个月，产品设计了2周。当开发工程是第一次听说该需求的时候，发现开发的时间是2天。工程师据理力争，加班加点1周搞定。最后的结论是工程师非常不给力，不配合。就像工程师讨厌类似需求一样。要协调一个大项目，希望获得别人的配合，也需要尽早沟通。 有效沟通的另外一个重点是“不要跑题”。很多看起来很接近的问题，本质上是完全不同的问题。比如：一个会议的主题是“如何实施一个方案”，有人却可能提出“是否应该实施该方案”。 “如何实施”和“是否应该实施”是完全不同的两个问题，很多看起来相关的问题实际上跑题很远。“跑题”是导致无效沟通的重要原因。 良好沟通的奥秘在于能掌握TCP模式和UDP模式精髓，正确判断问题的紧急性，尽量提前沟通，避免跑题。 带人之道有些初为导师的工程师由于担心毕业生的能力太弱，安排任务时候谆谆教诲，最后感觉还是有所顾虑，干脆自己写代码。同样的事情发生在很多刚刚管理小团队的工程师身上。最终的结果他们：写完所有的代码，让下属无代码可写。“ 事必躬亲”当然非常糟糕，最终的往往是团队的整体绩效不高，团队成员的成长很慢，而自己却很累。 古人说：“用人不疑，疑人不用。”这句话并非“放之四海而皆准”。在古代，受限于通信技术，反馈延迟显著，而且信息在传递过程中有大量噪音，变形严重。在这种情况下，如果根据短期内收集的少量变形的信息做快速决断，容易陷于草率。在公司里，这句话用于选人环节更为恰当，应该改为：录用不疑，疑人不录。 考虑到招聘成本，就算是在录用层面，有时候也无法做到。作为一个小团队的管理者，能够快速准确的获取团队成员的各种反馈信息，完全不需要“用人不疑，疑人不用”。用人的真正理论基础来自于“探索和利用”(Exploration and Exploitation )。不能因为下属能做什么就只让他做什么，更不能因为下属一次失败就不给机会。 根据经典的“探索和利用”(Exploration and Exploitation )理论，良好的用人方式应该如下： 首选选择相信，在面临失败后，收缩信任度。 查找失败的原因，提供改进意见，提升下属的能力。 总是给下属机会，在恰当地时机给下属更高的挑战。 总之，苍天大树来自一颗小种子，要相信成长的力量。 效率、效率、效率经常看到有些同学给自己的绩效评分是100分——满分，原因是在过去一段时间太辛苦了，但最终的绩效却一般般。天道酬勤不错，但是天道更酬巧。工程师们都学过数据结构，不同算法的时间复杂度的差距，仅仅通过更长的工作时间是难以弥补的。为了提升工作学习效率，我们需要注意以下几点： 主要关注效率提升。很多时候，与效率提升所带来的收益相比，延长时间所带来的成果往往不值得一提。 要有清晰的结果导向思维。功劳和苦劳不是一回事。 做正确的事情，而不仅仅正确地做事情。这是一个被不断提起的话题，但是错误每天都上演。为了在规定的时间内完成一个大项目，总是要有所取舍。如果没有重点，均匀发力，容易事倍功半。如果“南辕北辙”，更是可悲可叹。 架构师能力模型前面我们已经讲完了原则和一些困惑，那么工程师到底应该怎么提升自己呢？ 成为优秀的架构师是大部分初中级工程师的阶段性目标。优秀的架构师往往具备七种核心能力：编程能力、调试能力、编译部署能力、性能优化能力、业务架构能力、在线运维能力、项目管理能力和规划能力。 这几种能力之间的关系大概如下图。编程能力、调试能力和编译部署能力属于最基础的能力。不能精通掌握这三种能力，很难在性能优化能力和业务架构能力方面有所成就。具备了一定的性能优化能力和业务架构能力之后，才能在线运维能力和项目管理能力方面表现优越。团队管理能力是最高能力，它对项目管理能力的依赖度更大。 编程能力对工程师而言，编程是最基础的能力，必备技能。其本质是一个翻译能力，将业务需求翻译成机器能懂的语言。 提升编程能力的书籍有很多。精通面向对象和设计模式是高效编程的基础。初级工程师应该多写代码、多看代码。找高手做Code Review，也是提升编程水平的捷径。 调试能力程序代码是系统的静态形式，调试的目的是通过查看程序的运行时状态来验证和优化系统。本质上讲，工程师们通过不断调试可以持续强化其通过静态代码去预测运行状态的能力。所以调试能力也是工程师编程能力提升的关键手段。很早之前有个传说：“调试能力有多强，编程能力就有多强。”不过现在很多编辑器的功能很强大，调试能力的门槛已经大大降低。 调试能力是项目能否按时、高质量提交的关键。即使一个稍具复杂度的项目，大部分工程师也无法一次性准确无误的完成。大项目都是通过不断地调试进行优化和纠错的。所以调试能力是不可或缺的能力。 多写程序，解决Bug，多请教高手是提升调试能力的重要手段。 编译部署能力编译并在线上部署运行程序是系统上线的最后一个环节。随着SOA架构的普及以及业务复杂度的增加，大部分系统只是一个完整业务的一个环节，因此，本地编译和运行并不能完全模拟系统在线运行。为了快速验证所编写程序的正确性，编译并在线上部署就成了必要环节。所以编译部署能力是一个必备技能。 让盘根错节的众多子系统运行起来是个不小的挑战。得益于SOA架构的普及以及大量编译、部署工具的发展，编译部署的门槛已经大大降低。基于应用层进行开发的公司，已经很少有“编译工程师”的角色了。但是对于初级工程师而言，编译部署仍然不是一个轻松的事情。 性能优化能力衡量一个系统成功的一个重要指标是使用量。随着使用量的增加和业务复杂度的增加，大部分系统最终都会碰到性能问题。 性能优化能力是一个综合能力。因为： 影响系统性能的因素众多，包括：数据结构、操作系统、虚拟机、CPU、存储、网络等。为了对系统性能进行调优，架构师需要掌握所有相关的技术。 精通性能优化意味着深刻理解可用性、可靠性、一致性、可维护性、可扩展性等的本质。 性能优化与业务强耦合，最终所采取的手段是往往折衷的结果。所以，性能优化要深谙妥协的艺术。 可以说，性能优化能力是工程师们成长过程中各种技能开始融会贯通的一个标志。这方面可以参考之前的博客文章“常见性能优化策略的总结”。市场上还有很多与性能优化相关的书籍，大家可以参考。多多阅读开源框架中关于性能优化方面的文档和代码也不失为好的提升手段。动手解决线上性能问题也是提升性能优化能力的关键。如果有机会，跟着高手学习，分析性能优化解决方案案例（我们技术博客之前也发表了很多这方面的文章），也是快速提升性能优化能力的手段。 在线运维能力如果说性能优化能力体现的是架构师的静态思考能力，在线运维能力考验的就是动态反应能力。残酷的现实是，无论程序多么完美，Bug永远存在。与此同时，职位越高、责任越大，很多架构师需要负责非常重要的在线系统。对于线上故障，如果不能提前预防以及快速解决，损失可能不堪设想，所以在线运维能力是优秀架构师的必备技能。 为了对线上故障进行快速处理，标准化的监控、上报、升级，以及基本应对机制当然很重要。通过所观察到的现象，快速定位、缓解以及解决相关症状也相当关键。这要求架构师对故障系统的业务、技术具备通盘解读能力。解决线上故障的架构师就好比一个在参加比赛F1的车手。赛车手必须要了解自身、赛车、对手、同伴、天气、场地等所有因素，快速决策，不断调整。架构师必须要了解所有技术细节、业务细节、处理规范、同伴等众多因素，快速决断，迅速调整。 在线运维本质上是一个强化学习的过程。很多能力都可以通过看书、查资料来完成，但在线运维能力往往需要大量的实践来提升。 业务架构能力工程师抱怨产品经理的故事屡见不鲜，抱怨最多的主要原因来自于需求的频繁变更。需求变更主要有两个来源：第一个原因是市场改变或战略调整，第二个原因是伪需求。对于第一个原因，无论是工程师还是产品经理，都只能无奈的接受。优秀的架构师应该具备减少第二种原因所导致的需求变更的概率。 伪需求的产生有两个原因： 第一个原因是需求传递变形。从信息论的角度来讲，任何沟通都是一个编码和解码的过程。典型的需求从需求方到产品经理，最终到开发工程师，最少需要经历三次编码和解码过程。而信息的每一次传递都存在一些损失并带来一些噪音，这导致有些时候开发出来的产品完全对不上需求。此外，需求方和产品经理在需求可行性、系统可靠性，开发成本控制方面的把控比较弱，也会导致需求变形。 第二个原因就是需求方完全没有想好自己的需求。 优秀的架构师应该具备辨别真伪需求的能力。应该花时间去了解客户的真实业务场景，具备较强的业务抽象能力，洞悉客户的真实需求。系统的真正实施方是工程师，在明确客户真实需求后，高明的架构师应该具备准确判断项目对可行性、可靠性、可用性等方面的要求，并能具备成本意识。最后，由于需求与在线系统的紧耦合关系，掌握在线系统的各种细节也是成功的业务架构的关键。随着级别的提升，工程师所面对的需求会越来越抽象。承接抽象需求，提供抽象架构是架构师走向卓越的必经之途。 市场上有一些关于如何成为架构师的书，大家可以参考。但是架构能力的提升，实践可能是更重要的方式。业务架构师应该关注客户的痛点而不是PRD文档，应该深入关注真实业务。掌握现存系统的大量技术和业务细节也是业务架构师的必备知识。 项目管理能力作为工业时代的产物，分工合作融入在互联网项目基因里面。架构师也需要负责几个重大项目才能给自己正名。以架构师角色去管理项目，业务架构能力当然是必备技能。此外，人员管理和成本控制意识也非常重要。 项目管理还意味着要有一个大心脏。重大项目涉及技术攻关、人员变动、需求更改等众多可变因素。面临各种变化，还要在确保目标顺利达成，需要较强的抗压能力。 人员管理需要注意的方面包括：知人善用，优化关系，简化沟通，坚持真理。 知人善用意味着架构师需要了解每个参与者的硬技能和软素质。同时，关注团队成员在项目过程中的表现，按能分配。 优化关系意味着管理团队的情绪，毕竟项目的核心是团队，有士气的团队才能高效达成目标。 简化沟通意味着快速决策，该妥协的时候妥协，权责分明。 坚持真理意味着顶住压力，在原则性问题上绝不退步。 成本控制意味着对项目进行精细化管理，需要遵循如下几个原则： 以终为始、确定里程碑。为了达成目标，所有的计划必须以终为始来制定。将大项目分解成几个小阶段，控制每个阶段的里程碑可以大大降低项目失败的风险。 把控关键路径和关键项目。按照关键路径管理理论（CPM）的要求，架构师需要确定每个子项目的关键路径，确定其最早和最晚启动时间。同时，架构师需要关注那些可能会导致项目整体延期的关键节点，并集中力量攻破。 掌控团队成员的张弛度。大项目持续时间会比较长，也包含不同工种。项目实施是一个不断变化的动态过程，在这个过程中不是整个周期都很紧张，不是所有的工种都一样忙。优秀的架构师必须要具备精细阅读整体项目以及快速反应和实时调整的能力。这不仅仅可以大大降低项目成本，还可以提高产出质量和团队满意度。总体来说，“前紧后松”是项目管理的一个重要原则。 项目管理方面的书籍很多。但是，提高业务架构能力同样重要。积极参与大项目并观察别人管理项目的方式也是非常重要的提升手段。 团队管理能力不想做CTO的工程师不是一个好的架构师。走向技术管理应该是工程师的一个主流职业规划。团队管理的一个核心能力就是规划能力，这包括项目规划和人员规划。良好的规划需要遵循如下原则： 规划是利益的博弈。良好的规划上面对得起老板，中间对得起自己，下面对得起团队。在三者利益者寻找平衡点，实现多方共赢考验着管理者的智慧和精细拿捏的能力。 任何规划都比没有规划好。没有规划的团队就是没头的苍蝇，不符合所有人的利益。 规划不是本本主义。市场在变，团队在变，规划也不应该一成不变。 客户至上的是项目规划的出发点。 就人员规划而言，规划需要考量团队成员的能力、绩效、成长等多方面的因素。 市场上有很多规划管理方面的书籍，值得阅读。最优化理论虽然是技术书籍，但它是规划的理论基础，所以不妨多看看翻阅一下。从自我规划开始，多多学习别人的规划也是规划能力提升的重要手段。 总结因为受邀去做一个关于“一边工作，一边学习”的分享，作者花了一段时间去思考和汇总学习方法论，接着每天不断地采集谣言并尝试解惑，再根据个人经验绘制出优秀架构师的能力模型，最后汇集成文。 文章系统性地阐述了学习原则、分析了常见困惑，并制定明确学习目标，期望对工程师们的工作学习有所帮助。需要申明的是，文章内容挂一漏万，所谓的架构师能力模型也是作者的个人观点。欢迎大家在评论中分享自己在学习成长方面的心得。","categories":[{"name":"thinking","slug":"thinking","permalink":"https://kevinyangI.github.io/categories/thinking/"}],"tags":[{"name":"thinking","slug":"thinking","permalink":"https://kevinyangI.github.io/tags/thinking/"}],"keywords":[{"name":"thinking","slug":"thinking","permalink":"https://kevinyangI.github.io/categories/thinking/"}]},{"title":"Add Two Numbers II || LeetCode-445","slug":"leetcode-445","date":"2017-09-10T04:24:54.000Z","updated":"2018-07-24T08:27:04.737Z","comments":true,"path":"2017/09/10/leetcode-445/","link":"","permalink":"https://kevinyangI.github.io/kevinyangI.github.io/2017/09/10/leetcode-445/","excerpt":"","text":"Problem link： https://leetcode.com/problems/add-two-numbers-ii/#/description You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Follow up: What if you cannot modify the input lists? In other words, reversing the lists is not allowed. Example: Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 &lt;问题描述&gt; 给定两个非负整形的非空链表，整数的每一位以正常的顺序存储在链表中 你可以假定两个整数都没有前导的零 给出的addTwoNumbers函数应该以链表形式返回两个整数的和 输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 8 -&gt; 0 -&gt; 7 Approach #1 (利用reverse()函数反转链表)Analysis这道题是之前那道Add Two Numbers的拓展，可以看到这道题的最高位在链表的首位置，如果我们将链表反转一下，然后参考之前那道题的解决方法，问题就变得很容易了。关键在于如何实现链表反转函数reverse()。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; if (l1 == null &amp;&amp; l2 == null) &#123; return null; &#125; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; l1 = reverse(l1); // 链表l1反转 l2 = reverse(l2); // 链表l2反转 // resultList, resultNode, resultNext必须初始化，否则编译不通过 ListNode resultList = null; // 返回链表 ListNode resultNode = null; // 头节点 ListNode resultNext = null; // 每次新插入的节点 int carry = 0; // 进位 while(l1 != null &amp;&amp; l2 != null) &#123; resultNext = new ListNode(l1.val + l2.val + carry); carry = resultNext.val / 10; // 计算进位 resultNext.val = resultNext.val % 10; // 计算该位的数值 if (resultList == null) &#123; // 头节点为空，即插入的节点为返回链表的第一个节点时 resultNode = resultNext; resultList = resultNext; &#125; else &#123; // 头节点不为空 resultNode.next = resultNext; resultNode = resultNext; &#125; l1 = l1.next; l2 = l2.next; &#125; while (l1 != null) &#123; // 链表l1比链表l2长，处理链表l1的高位 resultNext = new ListNode(l1.val + carry); carry = resultNext.val / 10; resultNext.val = resultNext.val % 10; resultNode.next = resultNext; resultNode = resultNext; l1 = l1.next; &#125; while (l2 != null) &#123; // 链表l2比链表l1长，处理链表l2的高位 resultNext = new ListNode(l2.val + carry); carry = resultNext.val / 10; resultNext.val = resultNext.val % 10; resultNode.next = resultNext; resultNode = resultNext; l2 = l2.next; &#125; if (carry &gt; 0) &#123; // 最高位产生进位，需要新建节点进行存储 resultNext = new ListNode(carry); resultNode.next = resultNext; &#125; return reverse(resultList); // 返回的链表进行反转操作后再返回&#125;// 单链表实现反转操作函数public ListNode reverse(ListNode current) &#123; // initialization ListNode previousNode = null; ListNode nextNode = null; while (current != null) &#123; // save the next node nextNode = current.next; // update the value of \"next\" current.next = previousNode; // shift the pointers previousNode = current; current = nextNode; &#125; return previousNode;&#125; Complexity时间复杂度：O(n) 空间复杂度：O(1)O(n) Approach #2 (利用栈的后进先出存储节点数据)Analysis这里题目要求不使用reverse()函数，反转链表而不修改链表顺序，还有一种方法是利用栈来转换。由于加法需要从最低位开始运算，而最低位在链表末尾，链表只能从前往后遍历，没法取到前面的元素，我们可以利用栈来保存所有的元素，然后利用栈的后进先出的特点就可以从后往前取数字了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public ListNode addTwoNumbers(ListNode l1, ListNode l2)&#123; Stack&lt;integer&gt; stack1 = new Stack&lt;integer&gt;(); Stack&lt;integer&gt; stack2 = new Stack&lt;integer&gt;(); if (l1 == null &amp;&amp; l2 == null) &#123; return null; &#125; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; while (l1 != null) &#123; stack1.push(l1.val); l1 = l1.next; &#125; while (l2 != null) &#123; stack2.push(l2.val); l2 = l2.next; &#125; // resultNode, resultCurrent必须初始化 ListNode resultNode = new ListNode(0); // 头节点 ListNode resultCurrent = new ListNode(0); // 每次新插入的节点 int carry = 0; // 进位 while (!stack1.isEmpty() &amp;&amp; !stack2.isEmpty()) &#123; resultCurrent = new ListNode(stack1.pop() + stack2.pop() + carry); carry = resultCurrent.val / 10; // 计算进位 resultCurrent.val = resultCurrent.val % 10; // 计算该位的数值 // 构建链表方法：每次新建的节点插在head位置之前(头插法？) resultCurrent.next = resultNode.next; resultNode.next = resultCurrent; &#125; while (!stack1.isEmpty()) &#123; // 链表l1比链表l2长，处理链表l1的高位 resultCurrent = new ListNode(stack1.pop() + carry); carry = resultCurrent.val / 10; resultCurrent.val = resultCurrent.val % 10; resultCurrent.next = resultNode.next; resultNode.next = resultCurrent; &#125; while (!stack2.isEmpty()) &#123; // 链表l2比链表l1长，处理链表l2的高位 resultCurrent = new ListNode(stack2.pop() + carry); carry = resultCurrent.val / 10; resultCurrent.val = resultCurrent.val % 10; resultCurrent.next = resultNode.next; resultNode.next = resultCurrent; &#125; if (carry &gt; 0) &#123; // 最高位产生进位，需要新建节点进行存储 resultCurrent = new ListNode(carry); resultCurrent.next = resultNode.next; resultNode.next = resultCurrent; &#125; return resultNode.next;&#125; Complexity时间复杂度：O(n) 空间复杂度：O(1)O(n)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kevinyangI.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://kevinyangI.github.io/tags/leetcode/"}],"keywords":[{"name":"leetcode","slug":"leetcode","permalink":"https://kevinyangI.github.io/categories/leetcode/"}]},{"title":"Four Sum || LeetCode-18","slug":"leetcode-18","date":"2017-09-06T14:25:54.000Z","updated":"2018-07-24T08:27:21.567Z","comments":true,"path":"2017/09/06/leetcode-18/","link":"","permalink":"https://kevinyangI.github.io/kevinyangI.github.io/2017/09/06/leetcode-18/","excerpt":"","text":"Problem link： https://leetcode.com/problems/4sum/#/description Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is: [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] &lt;问题描述&gt; 给定一个整形数组，需要从数组中找出四个整数，使得它们的和等于另外一个给定的整数 你可以假定每一个输入有且仅有一个答案，并且不能使用同一个元素两次 给出的fourSum函数应该返回找到的四个整数值 输入：numbers = [1, 0, -1, 0, -2, 2], target = 0 (注意：输入的数组不一定有序) 输出：[[-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] Approach #1 (HashSet)Analysis可以延用之前处理Two Sum问题的方法，先是两层遍历，固定其中两个数nums[i]和nums[j]，然后利用low和high两个指针相互移动，找到和为target的四个整数，如果利用hashset中value的唯一性，判断其是否在hashset中出现过，若没有出现过则加入，low和high继续移动。 Code12345678910111213141516171819202122232425262728293031323334public List&lt;List&lt;integer&gt;&gt; fourSum(int[] nums, int target)&#123; List&lt;List&lt;integer&gt;&gt; result = new ArrayList&lt;List&lt;integer&gt;&gt;(); HashSet&lt;List&lt;integer&gt;&gt; set = new HashSet&lt;List&lt;integer&gt;&gt;(); Arrays.sort(nums); // 数组排序 for (int i = 0; i &lt; nums.length - 3; i++) &#123; for (int j = i + 1; j &lt; nums.length - 2; j++) &#123; int low = j + 1; int high = nums.length - 1; while(low &lt; high) &#123; int sum = nums[i] + nums[j] + nums[low] + nums[high]; if (sum == target) &#123; List&lt;integer&gt; list = new ArrayList&lt;integer&gt;(); list.add(nums[i]); list.add(nums[j]); list.add(nums[low]); list.add(nums[high]); if (!set.contains(list)) &#123; // 利用hashset处理重复元素 set.add(list); result.add(list); &#125; low++; // 结果不唯一，low和high指针应该继续移动 high--; &#125; else if (sum &gt; target) &#123; high--; &#125; else low++; &#125; &#125; &#125; return result;&#125; Complexity时间复杂度：O(n^2) 空间复杂度：O(1)O(n) Approach #2 (Sorting With Two Pointers)Analysis方法和Two Sum问题的差不多，只不过现在是查找四个元素。相比hashset方法，只是没有hashset的去重，需要独立处理nums[i]、nums[j]、nums[low]、nums[high]元素的重复问题。去除重复元素的关键就是，i，j，low，high首次碰到重复元素时允许遍历。 Code1234567891011121314151617181920212223242526272829303132333435363738394041public List&lt;List&lt;integer&gt;&gt; fourSum(int[] nums, int target)&#123; List&lt;List&lt;integer&gt;&gt; result = new ArrayList&lt;List&lt;integer&gt;&gt;(); Arrays.sort(nums); for (int i = 0; i &lt; nums.length - 3; i++) &#123; if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) // 处理nums[i]的重复 continue; for (int j = i + 1; j &lt; nums.length - 2; j++) &#123; if(j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) // 处理nums[j]的重复 continue; int low = j + 1; int high = nums.length - 1; while(low &lt; high)&#123; int sum = nums[i] + nums[j] + nums[low] + nums[high]; if (sum == target) &#123; List&lt;integer&gt; list = new ArrayList&lt;integer&gt;(); list.add(nums[i]); list.add(nums[j]); list.add(nums[low]); list.add(nums[high]); result.add(list); low++; high--; while (low &lt; high &amp;&amp; nums[low] == nums[low - 1]) &#123; // 处理nums[low]的重复 low++; &#125; while (low &lt; high &amp;&amp; nums[high] == nums[high + 1]) &#123; // 处理nums[high]的重复 high--; &#125; &#125; else if (sum &gt; target) &#123; high--; &#125; else low++; &#125; &#125; &#125; return result;&#125; Complexity时间复杂度：O(n^3) 空间复杂度：O(1)取决于排序算法","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kevinyangI.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://kevinyangI.github.io/tags/leetcode/"}],"keywords":[{"name":"leetcode","slug":"leetcode","permalink":"https://kevinyangI.github.io/categories/leetcode/"}]},{"title":"Three Sum Closest || LeetCode-16","slug":"leetcode-16","date":"2017-09-04T10:28:54.000Z","updated":"2018-07-24T08:13:55.552Z","comments":true,"path":"2017/09/04/leetcode-16/","link":"","permalink":"https://kevinyangI.github.io/kevinyangI.github.io/2017/09/04/leetcode-16/","excerpt":"","text":"Problem link： https://leetcode.com/problems/3sum-closest/#/description Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. For example, given array S = {-1 2 1 -4}, and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). &lt;问题描述&gt; 给定一个整形数组，需要从数组中找出三个整数，使得它们的和最接近另外一个给定的整数target 你不能使用同一个元素两次 给出的threeSumClosest函数应该返回最接近target的整数值 输入：numbers = [-1 2 1 -4], target = 1 (注意：输入的数组不一定有序) 输出：2 (-1 + 2 + 1 = 2) Approach #Solution (Sorting With Two Pointers)Analysis方法和Three Sum问题的差不多，只不过现在是要输出一个整数即可，并且不需要考虑nums[i]、nums[low]、nums[high]元素的重复问题，显得更加简单。需要注意一点的就是，判断low和high指针如何移动的条件。 Code12345678910111213141516171819202122232425public int threeSumClosest(int[] nums, int target)&#123; int closest_target = nums[0] + nums[1] + nums[2]; // closest_target为最接近的3Sum int smallest_difference_value = Math.abs(closest_target - target); // 3Sum与target之间最小的差值 Arrays.sort(nums); for (int i = 0; i &lt; nums.length - 2; i++) &#123; int low = i + 1; int high = nums.length - 1; while(low &lt; high)&#123; int sum = nums[i] + nums[low] + nums[high]; int temp = Math.abs(sum - target); if (temp &lt; smallest_difference_value) &#123; closest_target = sum; smallest_difference_value = temp; &#125; // sum的值必须无限接近target，以此来判断low和high指针的移动 if (sum &lt; target) &#123; low++; &#125;else high--; &#125; &#125; return closest_target;&#125; Complexity时间复杂度：O(n^2) 空间复杂度：O(1)取决于排序算法","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kevinyangI.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://kevinyangI.github.io/tags/leetcode/"}],"keywords":[{"name":"leetcode","slug":"leetcode","permalink":"https://kevinyangI.github.io/categories/leetcode/"}]},{"title":"Three Sum || LeetCode-15","slug":"leetcode-15","date":"2017-09-02T00:58:54.000Z","updated":"2018-07-24T08:27:49.987Z","comments":true,"path":"2017/09/02/leetcode-15/","link":"","permalink":"https://kevinyangI.github.io/kevinyangI.github.io/2017/09/02/leetcode-15/","excerpt":"","text":"Problem link： https://leetcode.com/problems/3sum/#/description Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. For example, given array S = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] Approach #1 (Brute Force)Analysis这道题是求三个数之和，比之前那道Two Sum两数之和要复杂一些，借鉴之前的解题思路。首先我们还是要对原数组进行排序(另一个原因是输出是有序的)，将值和索引存入hashmap中。然后开始两层遍历排序后的数组，这里注意不是遍历到最后一个停止，第一层遍历到倒数第三个就可以了，第二层遍历到倒数第二个就可以了。对于遍历到的数，我们用sum减去这两个数得到一个complement，我们只需要在hashmap中查找是否存在该值即可。需要注意的是，遍历时对重复元素的处理，避免出现重复元素。处理重复元素的关键在于，当i，j第一次遇到重复元素时，允许其遍历。 Code12345678910111213141516171819202122232425262728293031323334public List&lt;List&lt;integer&gt;&gt; threeSum(int[] nums)&#123; List&lt;List&lt;integer&gt;&gt; result= new ArrayList&lt;List&lt;integer&gt;&gt;(); if (nums.length &lt; 3 || nums == null) &#123; return result; &#125; Arrays.sort(nums); // 数组排序 int sum = 0; Map&lt;integer integer=\"\"&gt; map = new HashMap&lt;&gt;(); // 插入代码出错 for (int i = 0; i &lt; nums.length; i++) &#123; // 将数组存入hashmap map.put(nums[i], i); &#125; for (int i = 0; i &lt; nums.length - 2; i++) &#123; if (i==0 || nums[i] != nums[i - 1]) &#123; // 处理第一层遍历nums[i]的重复 for (int j = i + 1; j &lt; nums.length - 1; j++) &#123; int complement = sum - nums[i] - nums[j]; if (map.containsKey(complement) &amp;&amp; map.get(complement) &gt; j) &#123; List&lt;integer&gt; list = new ArrayList&lt;integer&gt;(); list.add(nums[i]); list.add(nums[j]); list.add(complement); result.add(list); &#125; while(nums[j] == nums[j + 1] &amp;&amp; j &lt; nums.length - 2)&#123; j++; //处理第二层遍历nums[j]的重复 &#125; &#125; &#125; &#125; return result;&#125; Complexity时间复杂度：O(n^2) 空间复杂度：O(1)O(n) Approach #2 (Sorting With Two Pointers)AnalysisThree Sum问题是Two Sum问题的升级，可以利用Two Sum问题的二分查找法来解决此问题。需要注意的是，Three Sum需要解决duplicate(重复)问题，3个数相加返回数值而不是它的index。首先，同样还是先对数组进行排序。然后，从索引0开始到倒数第三个位置（num.length-3)进行遍历，假定nums[i]就是第一个加数，然后从i+1的位置开始，利用二分查找(low、high指针)进行Two Sum问题的运算。 Code12345678910111213141516171819202122232425262728293031323334353637383940public List&lt;List&lt;integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;integer&gt;&gt; result = new ArrayList&lt;List&lt;integer&gt;&gt;(); if (nums.length &lt; 3 || nums == null) &#123; return result; &#125; Arrays.sort(nums); //数组排序 for (int i = 0; i &lt; nums.length - 2; i++) &#123; if(i == 0 || nums[i] != nums[i - 1])&#123; // 处理nums[i]的重复 int low = i + 1; int high = nums.length - 1; while(low &lt; high) &#123; int sum = nums[i] + nums[low] + nums[high]; if (sum == 0) &#123; List&lt;integer&gt; list = new ArrayList&lt;integer&gt;(); list.add(nums[i]); list.add(nums[low]); list.add(nums[high]); result.add(list); low++; high--; while (low &lt; high &amp;&amp; nums[low] == nums[low - 1]) &#123; low++; //处理nums[low]的重复 &#125; while (low &lt; high &amp;&amp; nums[high] == nums[high + 1]) &#123; high--; //处理nums[high]的重复 &#125; &#125; else if (sum &gt; 0) &#123; high--; &#125; else low++; &#125; &#125; &#125; return result;&#125; Complexity时间复杂度：O(n^2) 空间复杂度：O(1)取决于排序算法 Approach #3 (HashSet)Analysis在这个问题中，我们需要输出非重复元素的结果，可以联想到利用hashset来处理这类问题。当找到一个3sum==0的情况时，判断是否在结果hashset中出现过，没有出现过则添加(利用hashset的value唯一性）。因为结果不唯一，此时不能停止，应该继续搜索，low和high指针同时挪动。 Code12345678910111213141516171819202122232425262728293031323334353637public List&lt;List&lt;integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;integer&gt;&gt; result = new ArrayList&lt;List&lt;integer&gt;&gt;(); if (nums.length &lt; 3 || nums == null) &#123; return result; &#125; HashSet&lt;List&lt;integer&gt;&gt; hash = new HashSet&lt;List&lt;integer&gt;&gt;(); Arrays.sort(nums); for (int i = 0; i &lt; nums.length - 2; i++) &#123; //这种处理重复元素的方式比较容易理解 if(i &gt; 0 || nums[i] == nums[i - 1]) continue; int low = i + 1; int high = nums.length - 1; while(low &lt; high)&#123; int sum = nums[i] + nums[low] + nums[high]; if (sum == 0) &#123; List&lt;integer&gt; list = new ArrayList&lt;integer&gt;(); list.add(nums[i]); list.add(nums[low]); list.add(nums[high]); if (!hash.contains(list)) &#123; hash.add(list); result.add(list); &#125; low++; high--; &#125; else if (sum &lt; 0) &#123; low++; &#125; else high--; &#125; &#125; return result;&#125; Complexity时间复杂度：O(n^2) 空间复杂度：O(1)O(n)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kevinyangI.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://kevinyangI.github.io/tags/leetcode/"}],"keywords":[{"name":"leetcode","slug":"leetcode","permalink":"https://kevinyangI.github.io/categories/leetcode/"}]},{"title":"Add Two Numbers || LeetCode-2","slug":"leetcode-2","date":"2017-08-28T00:58:54.000Z","updated":"2018-07-24T07:42:38.151Z","comments":true,"path":"2017/08/28/leetcode-2/","link":"","permalink":"https://kevinyangI.github.io/kevinyangI.github.io/2017/08/28/leetcode-2/","excerpt":"","text":"Problem link： https://leetcode.com/problems/3sum-closest/#/description You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 &lt;问题描述&gt; 给定两个非负整形的非空链表，整数的每一位以相反的顺序存储在链表中 你可以假定两个整数都没有前导的零 给出的addTwoNumbers函数应该以链表形式返回两个整数的和 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 Approach #SolutionAnalysis本题思路很简单，按照加法原理从末尾到首位，每一位对齐相加即可。关键在于如何处理不同长度的数字，以及进位和最高位的判断。若有一个为null时，返回不为null的那个ListNode和进位相加的值；若都不为null时，返回两个ListNode和进位相加的值。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; if (l1 == null &amp;&amp; l2 == null) &#123; return null; &#125; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; // resultList, resultNode, resultNext必须初始化，否则编译不通过 ListNode resultList = null; // 返回链表 ListNode resultNode = null; // 头节点 ListNode resultNext = null; // 每次新插入的节点 int carry = 0; // 进位 while(l1 != null &amp;&amp; l2 != null) &#123; resultNext = new ListNode(l1.val + l2.val + carry); carry = resultNext.val / 10; // 计算进位 resultNext.val = resultNext.val % 10; // 计算该位的数值 if (resultList == null) &#123; // 头节点为空，即插入的节点为返回链表的第一个节点时 resultNode = resultNext; resultList = resultNext; &#125; else &#123; // 头节点不为空 resultNode.next = resultNext; resultNode = resultNext; &#125; l1 = l1.next; l2 = l2.next; &#125; while (l1 != null) &#123; // 链表l1比链表l2长，处理链表l1的高位 resultNext = new ListNode(l1.val + carry); carry = resultNext.val / 10; resultNext.val = resultNext.val % 10; resultNode.next = resultNext; resultNode = resultNext; l1 = l1.next; &#125; while (l2 != null) &#123; // 链表l2比链表l1长，处理链表l2的高位 resultNext = new ListNode(l2.val + carry); carry = resultNext.val / 10; resultNext.val = resultNext.val % 10; resultNode.next = resultNext; resultNode = resultNext; l2 = l2.next; &#125; if (carry &gt; 0) &#123; // 最高位产生进位，需要新建节点进行存储 resultNext = new ListNode(carry); resultNode.next = resultNext; &#125; return resultList; &#125; // 递归写法 参考：https://segmentfault.com/a/1190000002986101 public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; return addList(l1, l2, 0); &#125; public ListNode addList(ListNode l1, ListNode l2, int carry)&#123; if(l1 == null &amp;&amp; l2 == null)&#123; return carry == 0? null : new ListNode(carry); &#125; if(l1 == null &amp;&amp; l2 != null)&#123; l1 = new ListNode(0); &#125; if(l2 == null &amp;&amp; l1 != null)&#123; l2 = new ListNode(0); &#125; int sum = l1.val + l2.val + carry; ListNode curr = new ListNode(sum % 10); curr.next = addList(l1.next, l2.next, sum / 10); return curr; &#125;&#125; Complexity时间复杂度：O(n) 时间复杂度：O(n)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kevinyangI.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://kevinyangI.github.io/tags/leetcode/"}],"keywords":[{"name":"leetcode","slug":"leetcode","permalink":"https://kevinyangI.github.io/categories/leetcode/"}]},{"title":"Two Sum || LeetCode-1","slug":"leetcode-1","date":"2017-08-20T02:50:55.000Z","updated":"2018-07-24T08:48:45.295Z","comments":true,"path":"2017/08/20/leetcode-1/","link":"","permalink":"https://kevinyangI.github.io/kevinyangI.github.io/2017/08/20/leetcode-1/","excerpt":"","text":"Problem link： https://leetcode.com/problems/3sum-closest/#/description Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given numbers = [2, 7, 11, 15], target = 9, Because numbers[0] + numbers[1] = 2 + 7 = 9, return [0, 1]. &lt;问题描述&gt; 给定一个整形数组，需要从数组中找出两个整数，使得它们的和等于另外一个给定的整数 你可以假定每一个输入有且仅有一个答案，并且不能使用同一个元素两次 给出的twoSum函数应该返回找到的这两个整数的索引值，而且index1必须小于index2 输入：numbers = {2, 7, 11, 15}, target = 9 (注意：输入的数组不一定有序) 输出：index1 ＝ 0， index2 ＝ 1 Approach #1 (Brute Force)Analysis首先看到题目之后，很容易就能想到O(n^2)的方法，就是通过双重循环遍历数组中所有元素的两两结合，当出现符合的target时返回两个元素的索引。注意内存循环应该从外层循环索引的下一个开始搜索，避免查找到两个相同的元素。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.*;class TwoSum &#123; public int[] twoSum(int[] numbers, int target) &#123; int[] result = new int[2]; for (int i=0; i&lt;numbers.length; i++) &#123; for (int j=i+1; j&lt;numbers.length; j++) &#123; if (numbers[j] == target - numbers[i]) &#123; result[0] = i; result[1] = j; &#125; &#125; &#125; return result; &#125;&#125;// leetcode很好的一点就是不用考虑输入输出，只需要提交你的解决方案// 这是我自己写的一个输入输出测试，Java语言处理输入有点烦。。public class Solution001&#123; public static void main(String[] args)&#123; int count = 0; int target; int[] numbers = new int[10]; int[] temp = new int[10]; int[] results = new int[2]; Scanner in = new Scanner(System.in); System.out.println(\"please give an array of intergers and a target:\"); while(in.hasNextInt()) temp[count++] = in.nextInt(); target = temp[count-1]; for(int i=0; i&lt;count-1; i++) numbers[i] = temp[i]; TwoSum ts = new TwoSum(); results = ts.twoSum(numbers, target); System.out.print(results[0] + \" \" + results[1]); System.out.println(); &#125;&#125; Complexity时间复杂度：O(n^2) 空间复杂度：O(1)O(1) Approach #2 (Two-pass Hash Table)Analysis为了改善运行时的复杂度，我们需要一种更有效的方法来检查数组中是否存在互补。如果存在互补，我们需要查找它的索引。将数组中每个元素映射到其索引的最好方法是什么？很容易就联想到了哈希表。 我们减少了查找时间从O(n)到O(1)的交易空间的速度。哈希表是为这个目的而建立的，它支持在近恒定时间内快速查找。所谓“近”，是因为如果发生碰撞，查找可能退化为O(n)的时间。但哈希表查找应摊销O(1)的时间，只要散列函数仔细选择。 一个简单的实现使用两个迭代。第一次遍历数组先将所有元素和它的下标作为key-value对存入Hashmap中，第二次遍历数组时根据目标和与当前元素之差，在Hashmap中找相应的差值。如果存在该差值，说明存在两个数之和是目标和。此时记录下当前数组元素下标并从Hashmap中取出数组元素下标即可。Hashmap获取元素的时间复杂度是O(1)，所以总的时间复杂度仍不超过O(n)。 注意：判定是否存在该差值时，要同时判断该差值的下标是不是当前遍历的元素下标，以避免重复。 Code1234567891011121314151617public int[] twoSum(int[] numbers, int target) &#123; int[] result = new int[2]; Map&lt;integer integer=\"\"&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; numbers.length; i++) &#123; map.put(numbers[i], i); &#125; for (int i = 0; i &lt; numbers.length; i++) &#123; int complement = target - numbers[i]; if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123; result[0] = i; result[1] = map.get(complement); return result; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\");&#125; Complexity时间复杂度：O(n) 空间复杂度：O(1)O(n) Approach #3 (One-pass Hash Table)Analysis可以对Two-pass Hash Table进行优化，通过一次遍历即可。当我们在表中进行迭代和插入元素时，我们也回头检查表中是否存在当前元素的互补。如果它存在，我们已经找到一个解决方案，并立即返回。 Code12345678910111213141516171819public int[] twoSum(int[] numbers, int target) &#123; int[] result = new int[2]; Map&lt;integer integer=\"\"&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; numbers.length; i++) &#123; map.put(numbers[i], i); &#125; for (int i = 0; i &lt; numbers.length; i++) &#123; int complement = target - numbers[i]; if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123; result[0] = i; result[1] = map.get(complement); return result; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\");&#125; Complexity时间复杂度：O(n) 空间复杂度：O(1)O(n) Approach #4 (Sorting With Two Pointers)Analysis问题描述：在一个数组（无序）中快速找出两个数字，使得两个数字之和等于一个给定的值。假设数组中肯定存在至少一组满足要求。 《剑指Offer》P214（有序数组） 《编程之美》P176 容易想到在有序数组中进行查找。首先将原数组复制一遍，对新数组进行排序。排序后将双指针指向头部与尾部元素，进行迭代。如果双指针指向元素之和大于目标和，则将尾部指针向前移一位，反之则将头部指针向后移一位，直到双指针指向元素之和等于目标和，记录这两个元素的值，然后再遍历一遍旧数组，找出这两个元素的下标。 Code1234567891011121314151617181920212223242526272829303132333435363738394041public int[] twoSum(int[] numbers, int target) &#123; int[] result = new int[2]; int[] nums = new int[numbers.length]; for (int i = 0; i &lt; numbers.length; i++) &#123; // 复制数组 nums[i] = numbers[i]; &#125; if(nums == null || nums.length &lt; 2) return null; Arrays.sort(nums); // 数组排序 int left = 0; int right = nums.length - 1; while(left &lt; right) &#123; if(nums[left] + nums[right] == target) &#123; for (int i = 0; i &lt; numbers.length; i++) &#123; if(numbers[i] == nums[left]) result[0] = i; &#125; for (int i = 0; i &lt; numbers.length; i++) &#123; if(numbers[i] == nums[right] &amp;&amp; i != result[0]) // 避免查找到两个相同元素 result[1] = i; &#125; if (result[0] &gt; result[1]) &#123; // 保证找到的第一个整数索引比第二个要小 int temp = result[0]; result[0] = result[1]; result[1] = temp; &#125; return result; &#125; else if(nums[left] + nums[right] &gt; target) right--; else left++; &#125; return null;&#125; Complexity时间复杂度：O(nlogn) 空间复杂度：O(1) 取决于排序算法","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://kevinyangI.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://kevinyangI.github.io/tags/leetcode/"}],"keywords":[{"name":"leetcode","slug":"leetcode","permalink":"https://kevinyangI.github.io/categories/leetcode/"}]},{"title":"集中式 vs. 分布式系统架构","slug":"system-architecture","date":"2017-07-20T08:48:25.000Z","updated":"2018-09-02T09:48:50.218Z","comments":true,"path":"2017/07/20/system-architecture/","link":"","permalink":"https://kevinyangI.github.io/kevinyangI.github.io/2017/07/20/system-architecture/","excerpt":"前言随着计算机系统规模变得越来越大，将所有业务单元集中部署在一个或者若干个大型机上的体系结构物，已经越来越不能满足当今计算机系统，尤其是大型互联网系统的快速发展，各种灵活多变的系统架构模型层出不穷。同时，随着微型计算机的出现，越来越多廉价的PC机成为了各大IT企业架构的首选，分布式的处理方式越来越受到业界的青睐。计算机系统正在经历一场前所未有的从集中式到分布式架构的变革。 从集中式到分布式 自从20世纪60年代大型主机被发明出来以后，凭借其超强的计算和I/O处理能力以及在稳定性和安全性方面的卓越表现，在很长一段时间内，大型主机引领了计算机行业以及商业计算领域的发展。在大型主机的研发上最知名的当属IBM，其主导研发的革命性产品System/360系列大型主机，是计算机发展史上的一个里程碑，与波音707和福特T型车齐名，被誉为20世纪最重要的三大商业成就，IT界进入了大型主机时代。","text":"前言随着计算机系统规模变得越来越大，将所有业务单元集中部署在一个或者若干个大型机上的体系结构物，已经越来越不能满足当今计算机系统，尤其是大型互联网系统的快速发展，各种灵活多变的系统架构模型层出不穷。同时，随着微型计算机的出现，越来越多廉价的PC机成为了各大IT企业架构的首选，分布式的处理方式越来越受到业界的青睐。计算机系统正在经历一场前所未有的从集中式到分布式架构的变革。 从集中式到分布式 自从20世纪60年代大型主机被发明出来以后，凭借其超强的计算和I/O处理能力以及在稳定性和安全性方面的卓越表现，在很长一段时间内，大型主机引领了计算机行业以及商业计算领域的发展。在大型主机的研发上最知名的当属IBM，其主导研发的革命性产品System/360系列大型主机，是计算机发展史上的一个里程碑，与波音707和福特T型车齐名，被誉为20世纪最重要的三大商业成就，IT界进入了大型主机时代。 伴随着大型主机时代的到来，集中式的计算机系统架构也成为了主流。在那个时候，由于大型主机卓越的性能和良好的稳定性，其在单机处理能力方面的优势非常明显，使得IT系统快速进入了集中式处理阶段，其对应的计算机系统称为集中式系统。但从20世纪80年代以来，计算机系统向网络化和微型化的发展日趋明显，传统的集中式处理模型越来越不能适应人们的需求，具体表现在： 大型主机的人才培养成本非常高，通常一台大型主机汇集了大量精密的计算机组件，操作非常复杂，这对一个运维人员掌握其技术细节提出了非常高的要求。 大型主机也是非常昂贵的，通常一台配置较好的IBM大型主机，其售价达到上百万美元甚至更高，因此也只有像政府、金融和电信等企业才有能力采购大型主机。 集中式有非常明显的单点问题，大型主机虽然在性能和稳定性方面表现卓越，但并不代表其永远不会出故障。一旦一台大型主机出现了故障，那么整个系统将处于不可用的状态，后果相当严重。最后，随着业务的不断发展，用户访问量迅速提高，计算机系统的规模也在不断扩大，在单一大型主机上进行扩容往往比较困难。 随着PC机性能的不断提升和网络技术的快速普及，大型主机的市场份额变得越来越小，很多企业开始放弃原来的大型主机，而改用小型机和普通PC服务器来搭建分布式计算机。 对业内新闻比较关注的，一定知道阿里巴巴在2009年发起了一项”去IOE”运动。因为阿里巴巴从2008年开始各项业务都进入了井喷式的发展阶段，这对于后台IT系统的计算与存储能力提出了非常高的要求，一味地针对小型机和高端存储进行不断扩容，无疑会产生巨大的成本。同时，集中式的系统架构体系也存在着诸多单点问题，完全无法满足互联网应用爆炸式的发展需求。因此，为了解决业务快速发展给IT系统带来的巨大挑战，从2009年开始，阿里集团启动了”去IOE”计划，其电商系统开始正式迈入了分布式系统时代。 集中式系统架构所谓集中式系统就是指由一台或多台主计算机组成中心节点，数据集中存储于这个中心节点中，并且整个系统的所有业务单元都集中部署在这个中心节点上，系统所有的功能均由其集中处理。也就是说，集中式系统中，每个终端或客户端及其仅仅负责数据的录入和输出，而数据的存储与控制处理完全交由主机来完成。 集中式系统最大的特点就是部署结构简单，由于集中式系统往往基于底层性能卓越的大型主机，因此无需考虑如何对服务进行多个节点的部署，也就不用考虑多个节点之间的分布式协作问题。 分布式系统架构在《分布式系统概念与设计》注一书中，对分布式系统做了如下定义： 分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。 严格地讲，同一个分布式系统中的计算机在空间部署上是可以随意分布的，这些计算机可能被放在不同的机柜上，也可能在不同的机房中，甚至分布在不同的城市。无论如何，一个标准的分布式系统在没有任何特定业务逻辑约束的情况下，都会有以下几个特征： 分布性分布式系统中的多台计算机都会在空间上随意分布，同时，及其的分布情况也会随时变动。 对等性分布式系统中的计算机没有主从之分，既没有控制整个系统的主机，也没有被控制的从机，组成分布式系统的所有节点都是对等的。副本（Replica）是分布式系统最常见的概念之一，指的是分布式系统对数据和服务提供的一种冗余方式。在常见的分布式系统中，为了对外提高可用的服务，我们往往会对数据和服务进行副本处理。数据副本是指在不同的节点上持久化同一份数据，当某一个节点上存储的数据丢失时，可以从副本上读取到该数据，这是解决分布式系统数据丢失问题最为有效的手段。另一类副本是服务副本，指多个节点提供同样的服务，每个节点都有能力接收来自外部的请求并进行相应的处理。 并发性在一个计算机网络中，程序运行过程中的并发性操作是非常常见的行为，例如同一个分布式系统的多个节点，可能会并发地操作一些共享的资源，诸如数据库或分布式存储等，如何准确并高效地协调分布式并发操作也成为了分布式系统架构与设计中最大的挑战之一。 缺乏全局时钟一个典型的分布式系统是由一系列空间上随意分布的多个进程组成的，具有明显的分布性，这些进程之间通过交换消息来进行相互通信。因此，在分布式系统中，很难定义两个事件究竟谁先谁后，原因就是因为分布式系统缺乏一个全局的始终控制序列。 故障总是会发生组成分布式系统的所有计算机，都有可能发生任何形式的故障。一个被大量工程实践过的黄金定理是：任何在设计阶段考虑到的异常情况，一定会在系统实际运行中发生，并且，在系统实际运行中还会遇到很多在设计时未考虑到的异常故障。所以，除非需求指标允许，在系统设计时不能放过任何异常情况。 处理单点故障在整个分布式系统中，如果某个角色或者功能只有某台单机在支撑，那么这个节点称为单点，其发生的故障称为单点故障，也就是通常说的SPoF（Single Point of Failure），避免单点而对关键就是把这个功能从单机实现变为集群实现，当然，这种变化一般会比较困难，否则就不会有单点问题了。如果不能把单点变为集群实现，那么一般还有两种选择： 给这个单点做好备份，能够在出现问题时进行恢复，并且尽量做到自动恢复。 降低单点故障的影响范围。 集中式与分布式系统架构之间的比较目前，在IT系统架构设计中，对于服务器的配置方案主要有两种。 分布式，即根据业务功能、模块设计或行政部门及机构的不同，采用相对分散的中小型服务器； 集中式，即将所需的主机资源集中到少数的几台大型服务器中。 这两种方式，在投资成本、业务支撑及扩展能力、维护管理、方案拓展等方面，存在着比较显著的差异。 业务支撑及扩展能力采用三层结构设计的系统中，数据库层和应用层一般支持横向和纵向两种扩展方式。其中，横向指通过增加服务器台数来扩展某一层次的处理能力，纵向指通过对单台主机的CPU、内存等配件扩充来提高某一层次的处理能力。 分散式结构下，由于单台主机的处理能力比较有限，所以数据库层和应用层将主要依赖于横向扩充方式来支撑业务的扩展。横向扩充方式的实现，并不等同于简单地增加机器，有两个前提必须要满足。一是多台数据库服务器必须能够并行运行，这就要求使用并行版数据库软件。二是应用系统必须基于并行数据访问方式进行开发。在实际地使用中，由于并行版数据库软件使用较难、维护费用高、应用软件大多没有基于并行方式开发等原因，横向扩充方式实现起来相对较难。当业务处理需求发展到一定程度时，单台主机的处理能力，尤其是数据库服务的地处理能力，往往成为制约整体业务扩充能力的薄弱环节。 集中式结构下，除了可以采用横向方式进行扩充外，由于单台主机具备较好的扩充能力，因此可以采用纵向方式进行处理能力的扩充。纵向扩充方式，仅涉及硬件配件的增加，数据库软件和应用软件不需调整，实现起来相对容易。 投资成本机房建设成本采用分散方式进行系统建设，一般需要的主机数量从数台到数十台不等。这些主机，都需要基本的机房占地（包括主机自身面积和每台四周一米左右的维护空间）、承重设计、电力供应、制冷需求。累计到一起之后，通常对机房的基本建设提出很大的需求。尤其对于一些保密性要求较高的中心机房，机房建设成本往往不是以平面面积进行衡量，而是以立方面积进行计量的。这种情况下，每增加一台主机设备，将导致机房基本构建成本的大幅度上升。而采用集中方式进行系统建设，所需要的主机和存储设备大幅度减少，相应对占地面积、承重设计、电力供应、制冷设备等基本建设方面的要求都大大降低，从减少了机房建设成本。 硬件成本过去，在硬件成本的采购上，采用集中式结构通常会比采用分散式结构投资略大一些。现在，随着主机上分区技术的普遍采用，主机的CPU、内存等资源能够很好地加以均衡和利用，减少每台机器的“浪费”空间和资源，两种结构的投资差异不大，甚至常常出现分散式的投资比集中式的投资更大的情况。 软件成本集中式使用的CPU总数通常比分散式少。系统软件、数据库软件、应用软件等软件产品的采购费用是与CPU个数成正比的。因此，采用集中式，能够节约软件采购成本。 运行成本集中式结构的运行成本较低。由于采用较少的设备，在机房个数、机房空间、电源功率、机房制冷、保修费用等方面，集中式都比分散式相对节约。 使用灵活性分散式结构中，所有主机的功能单一，若需要变换功能，需要对系统进行较大调整。集中模式下，各分区的功能可以根据需要进行调整，如果将来有业务扩充或者功能增加时，实现起来比较容易。相比而言，集中模式的灵活性更强。 资源利用有效性分散式结构下，每台主机的资源被限制用于某一个固定的功能。当某台主机资源紧张时，即使其它主机还有大量的空闲资源，也无法调配给这台主机使用。只能通过系统升级的方式解决问题。而集中模式下，主机资源可以在同一台主机的不同分区之间动态调配。当某个分区资源紧张时，如果同一主机的其它分区上有空闲资源，可以随时动态调配给这个分区使用。另一方面，分散模式需要对每台主机都配置本地磁带机、光驱、显卡、显示器等设备。而集中模式则可以根据需要对每台主机只配置一套这类设备。因此，集中模式对系统资源的利用更加有效。 维护管理由于集中式采用服务器数量比分散式少，可以减少硬件的故障点，从而减少硬件维护的工作量，降低系统管理的繁琐程度。当然，由于设备相对比较集中，单台设备故障后的影响范围也就较大。因此，分散式结构下，单台设备故障导致的运行风险相对较小。集中式下，对选用主机的高可靠性要求更高。 方案拓展数据处理中心建立后，随之而来的，就是对灾难备份的考虑。在这个方面，分散式结构下，要建立灾难备份系统，难度相对较大。由于设备数量多、地点可能分散、平台不一定一致，对灾备技术的选择比较受限制，可选方案相对较少，甚至没有可选方案。而集中式结构下，能够实现灾备的方式，相对较多。 另一方面，采用分散式结构，灾备中心需要配置的备份设备比较多，投资相对更大。 综上所述，分散式和集中式两种模式，各有利弊。对于大型的数据处理中心，通常集中式更为适合。 参考文献: https://wenku.baidu.com/view/7c9081e2524de518964b7d4e.html 参考博客: http://www.cnblogs.com/szlbm/p/5588541.html","categories":[{"name":"system architecture","slug":"system-architecture","permalink":"https://kevinyangI.github.io/categories/system-architecture/"}],"tags":[{"name":"system architecture","slug":"system-architecture","permalink":"https://kevinyangI.github.io/tags/system-architecture/"}],"keywords":[{"name":"system architecture","slug":"system-architecture","permalink":"https://kevinyangI.github.io/categories/system-architecture/"}]},{"title":"BitTorrent协议与MagNet协议原理","slug":"bittorrent-magnet","date":"2017-07-10T06:36:15.000Z","updated":"2018-09-02T09:49:13.080Z","comments":true,"path":"2017/07/10/bittorrent-magnet/","link":"","permalink":"https://kevinyangI.github.io/kevinyangI.github.io/2017/07/10/bittorrent-magnet/","excerpt":"","text":"BitTorrent协议简介BitTorrent(简称BT)是一个文件分发协议，每个下载者在下载的同时不断向其他下载者上传已下载的数据。而在FTP，HTTP协议中，每个下载者在下载自己所需文件的同时，各个下载者之间没有交互。当非常多的用户同时访问和下载服务器上的文件时，由于FTP服务器处理能力和带宽的限制，下载速度会急剧下降，有的用户可能访问不了服务器。BT协议与FTP协议不同，特点是下载的人越多，下载速度越快，原因在于每个下载者将已下载的数据提供给其他下载者下载，充分利用了用户的上载带宽。通过一定的策略保证上传速度越快，下载速度也越快。在很短时间内，BitTorrent协议成为一种新的变革技术。 技术依赖BitTorrent 的发展依赖于peer-to-peer技术。对等网络 (Peer - to - Peer 简称 P2P) 的研究一直是国外知名学府和知名企业以及研发机构最关注的重点。P2P是近年来互联网最热门的技术，在VoIP、下载、流媒体、协调技术等领域得到飞速发展，被财富杂志评为影响互联网的四大科技之一，甚至被认为是代表无线宽带互联网未来的关键技术。 P2P技术体现了互联网最根本的内涵——自由和免费，它的主要优点如下： 对等性高：非中心化，互联网回归本色——联系和传输； 扩展性强：用户扩展与资源、服务、系统同步扩展； 健壮性高：服务分散和自适应，耐攻击、高容错性； 性价比高：P2P成本低、存储和技术能力强； 负载均衡：分布存储和技术，整个网络负载得以均衡。 在P2P网络中，每个参与的节点既是服务器又是客户端，既是信息的提供者又是信息的消费者。P2P信息检索的目的就是网络中的任意节点都可以提交检索的请求，然后这些检索通过相关信息的节点将会回应请求，按照某种路由机制路由到本地相关的内容，以对等的形式直接传送到请求节点上。 检索过程分为以下几个阶段：每个节点在加入网络的时候，会对存储在本节点上的内容进行索引，以满足本地内容检索的目的。然后按某种预定的规则选择一些节点作为自己的邻居，加入到P2P网络当中。发起者P提出检索请求q，并将q发送给自己的邻居，P的邻居收到q后，再按照某种策略转发给它在网络中的其它邻居节点。这样，q就在整个网络中传播开来。收到请求q的节点如果存储有相应内容信息，则将对应的内容返回。 如何在一个大规模分布的环境下定位资源是个十分具有挑战性的问题。集中体现在如何组建P2P网络，如何选择有效的资源请求路由策略以便以较少的消息通信开销，获得较多的相关查询结果返回，同时能够保证较好的服务均衡性。 原理简述普通的HTTP/FTP下载使用TCP/IP协议，BitTorrent协议是架构于TCP/IP协议之上的一个P2P文件传输协议，处于TCP/IP结构的应用层。 BitTorrent协议本身也包含了很多具体的内容协议和扩展协议，并在不断扩充中。 根据BitTorrent协议，文件发布者会根据要发布的文件生成提供一个.torrent文件，即种子文件，也简称为“种子”。 .torrent文件本质上是文本文件，包含Tracker信息和文件信息两部分。Tracker信息主要是BT下载中需要用到的Tracker服务器的地址和针对Tracker服务器的设置，文件信息是根据对目标文件的计算生成的，计算结果根据BitTorrent协议内的B编码规则进行编码。它的主要原理是需要把提供下载的文件虚拟分成大小相等的块，块大小必须为2k的整数次方（由于是虚拟分块，硬盘上并不产生各个块文件），并把每个块的索引信息和Hash验证码写入种子文件（.torrent）中。所以，种子文件（.torrent）就是被下载文件的“索引”。 下载过程下载者要下载文件内容，需要先得到相应的.torrent文件，然后使用BT客户端软件进行下载。 下载时，BT客户端首先解析.torrent文件得到Tracker地址，然后连接Tracker服务器。Tracker服务器回应下载者的请求，提供下载者其他下载者（包括发布者）的IP。下载者再连接其他下载者，根据.torrent文件，两者分别对方告知自己已经有的块，然后交换对方没有的数据。此时不需要其他服务器参与，分散了单个线路上的数据流量，因此减轻了服务器负担。 下载者每得到一个块，需要算出下载块的Hash验证码与.torrent文件中的对比，如果一样则说明块正确，不一样则需要重新下载这个块。这种规定是为了解决下载内容准确性的问题。 相关概念 Tracker：收集下载者信息的服务器，并将此信息提供给其他下载者，使下载者们相互连接起来，传输数据。种子：指一个下载任务中所有文件都被某下载者完整的下载，此时下载者成为一个种子。发布者本身发布的文件就是原始种子。也指.torrent文件。做种：发布者提供下载任务的全部内容的行为；下载者下载完成后继续提供给他人下载的行为。 MagNet协议简介MagNet协议，也就是磁力链接，简称磁链。以前的BT下载服务是需要一个tracker服务器来储存BT种子文件，但是MagNet URI协议是不一定需要tracker服务器的，原理类似于电驴，但不完全是电驴的翻版。MagNet每次连接的源头都是不固定的，也就没法查封源头。在BT被封锁以后MagNet将是主流下载方式。 它会根据文件内容的hash生成一个独特的指纹，有点类似于ISBN。这样，任何拥有此文件的人可以生成基于文件内容的指纹。它的另一个优势就是跨平台性，因为它是以普通文本存在，你可以简单的复制粘贴即可完成分享。 技术依赖Magnet不需要Tracker服务器，也不需要.torrent文件，仅需要一串字符就可以进行文件下载。 DHT技术：2002年，纽约大学的两个教授Petar Maymounkov和David Mazières发表了一篇论文，提出了一种真正去中心化的“点对点”下载模型，他们将其称为Kademlia方法。2005年，BT软件开始引入这种技术，在BT中被称为DHT协议（Distributed Hash Table，分布式哈希表）。 DHT是一种分布式存储方法。DHT的作用是找到那些与本机正在下载（上传）相同文件的对端主机（Peer），当然，实现这一过程并不依赖Tracker服务器。在DHT网络中的每个客户端负责一个小范围的路由，并负责存储一小部分数据，从而实现整个DHT网络的寻址和存储。这种信息获取方式保证了整个网络没有单个的中心，即使一个节点下线，依然可以通过其他节点来获取文件，因此也就不需要Tracker服务器来告诉你，其他节点在什么地方。 PEX：是Peer Exchange的简写，我们可以将其理解为“节点信息交换”。虽然DHT解决了去中心化的问题，但要在没有“中心协调员”（Tracker）的情况下实现高效寻址，就要借助PEX。PEX所提供的功能有点类似于以前的Tracker服务器，但工作方式却非常不同，我们可以打个比方来说明。 小赵在A班，她不认识B班的小何，也不认识C班的小温，但小赵认识同班的小王，而小王认识B班的小何，也可能还认识C班的小温，或者小王仅认识B班的小何，但小何认识C班的小温，而小温又认识同班的所有同学，结果就是小赵可以“无限”地延伸自己的关系网，不管怎样，总有一条沟通途径可以将这些同学联系在一起，待小赵“认识”了小温后，他们就可以直接沟通了，在P2P世界里，就是进行上传与下载。 原理简述Magnet links：磁力链接，简称磁链。DHT+PEX解决了BT“寻址”的问题，但是如何告诉BT客户端找（寻）什么又是另外一个问题。在.torrent文件中包含的内容就是用户真正要下载的文件的特征信息，或称为“电子指纹”，BT客户端知道了要找什么，也知道如何去找，于是P2P方式的下载、上传就实现了。以前BT客户端通过.torrent文件得知“要找什么”，现在，文件的“电子指纹”不再存放于.torrent中，而被放在了Magnet links中。 例如：magnet:?xt=urn:btih:36684b463ca2aa2f9347b18e9f6b1a9090bdb073&amp;dn=Microsoft+iSCSI+Initiator 分解一下这个地址： magnet：协议名。 xt：exact topic的缩写，表示资源定位点。BTIH（BitTorrent Info Hash）表示哈希方法名，这里还可以使用SHA1和MD5。这个值是文件的标识符，是不可缺少的。 dn：display name的缩写，表示向用户显示的文件名。这是一个可选项。 tr：tracker的缩写，表示tracker服务器的地址。这是一个可选项，本例中并未出现。 简化仅需要magnet:?xt=urn:btih:36684b463ca2aa2f9347b18e9f6b1a9090bdb073就够用了，如果附加dn（display name），在使用上会更加方便一些。 Magnet Link的好处至少包括两点：网络的可靠性得到了极大的增强；不存在“被拔线”的风险。由于不存在所谓的中央节点，审查将变得更加困难，“单点失效”的问题也就不存在了。此外，Magnet URI只是一个字符串，非常容易传播，根本无法禁止。因此，Magnet URI取代Tracker模式将是大势所趋，迟早会成为主流BT下载方式。 可能看出了DHT+PEX+Magnet Link模式中的一个问题——BT客户端的“第一步是如何迈出的”，套用在介绍PEX时使用的例子，那就是小赵是怎么“加入”A班的呢？这确实是个问题。解决这个问题依然需要一台服务器（bootstrap node），不过这台服务器所起的作用与Tracker不同，它仅负责接纳小赵进入A班，当小赵与A班中的同学“搭上了话”，之后这台服务器就没有什么用处了。bootstrap node可以是不同BT客户端厂商独立运营的，也可以是几家联合共用，总之，它是分散的，只要在客户端软件中内置一张表单，那客户端就将有非常多的入口可供选择。","categories":[{"name":"network","slug":"network","permalink":"https://kevinyangI.github.io/categories/network/"}],"tags":[{"name":"network","slug":"network","permalink":"https://kevinyangI.github.io/tags/network/"}],"keywords":[{"name":"network","slug":"network","permalink":"https://kevinyangI.github.io/categories/network/"}]},{"title":"Hiker主题预览","slug":"Hiker主题预览","date":"2016-10-24T03:07:20.000Z","updated":"2018-01-25T14:41:06.000Z","comments":true,"path":"2016/10/24/Hiker主题预览/","link":"","permalink":"https://kevinyangI.github.io/kevinyangI.github.io/2016/10/24/Hiker主题预览/","excerpt":"Hiker主题预览Hiker is an attractive theme for Hexo. called “Hiker”, short for “HikerNews”.","text":"Hiker主题预览Hiker is an attractive theme for Hexo. called “Hiker”, short for “HikerNews”.","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://kevinyangI.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://kevinyangI.github.io/tags/Hexo/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"https://kevinyangI.github.io/categories/Hexo/"}]},{"title":"Java 8系列之重新认识HashMap","slug":"Java 8系列之重新认识HashMap","date":"2016-06-24T03:58:55.000Z","updated":"2018-09-23T13:59:58.872Z","comments":true,"path":"2016/06/24/Java 8系列之重新认识HashMap/","link":"","permalink":"https://kevinyangI.github.io/kevinyangI.github.io/2016/06/24/Java 8系列之重新认识HashMap/","excerpt":"本文来自美团点评技术团队： Java 8系列之重新认识HashMap 摘要HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。 简介Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap。","text":"本文来自美团点评技术团队： Java 8系列之重新认识HashMap 摘要HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。 简介Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap。 下面针对各个实现类的特点做一些说明： (1) HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 (2) Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。 (3) LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 (4) TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。 对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。 通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。 内部实现搞清楚HashMap，首先需要知道HashMap是什么，即它的存储结构-字段；其次弄明白它能干什么，即它的功能实现-方法。下面我们针对这两个方面详细展开讲解。 存储结构-字段从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。 这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么？优点呢？ (1) 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。我们来看Node[JDK1.8]是何物。 1234567891011121314static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; //用来定位数组索引位置 final K key; V value; Node&lt;K,V&gt; next; //链表的下一个node Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125; public final K getKey()&#123; ... &#125; public final V getValue() &#123; ... &#125; public final String toString() &#123; ... &#125; public final int hashCode() &#123; ... &#125; public final V setValue(V newValue) &#123; ... &#125; public final boolean equals(Object o) &#123; ... &#125;&#125; Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。 (2) HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码： 1map.put(\"美团\",\"小美\"); 系统将调用”美团”这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。 如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。 在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下： 1234int threshold; // 所能容纳的key-value对极限 final float loadFactor; // 负载因子int modCount; int size; 首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。 结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。 size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。 在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考http://blog.csdn.net/liuqiyao_01/article/details/14475159 ，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。 这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考http://blog.csdn.net/v_july_v/article/details/6105630 。 功能实现-方法HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。 1. 确定哈希桶数组索引位置不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二): 1234567891011方法一：static final int hash(Object key) &#123; //jdk1.8 &amp; jdk1.7 int h; // h = key.hashCode() 为第一步 取hashCode值 // h ^ (h &gt;&gt;&gt; 16) 为第二步 高位参与运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;方法二：static int indexFor(int h, int length) &#123; //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的 return h &amp; (length-1); //第三步 取模运算&#125; 这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。 对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。 这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。 在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。 2. 分析HashMap的put方法HashMap的put方法执行过程可以通过下图来理解，自己有兴趣可以去对比源码更清楚地研究学习。 ①. 判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容； ②. 根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③； ③. 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals； ④. 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤； ⑤. 遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； ⑥. 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。 JDK1.8HashMap的put方法源码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public V put(K key, V value) &#123; // 对key的hashCode()做hash return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 步骤①：tab为空则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 步骤②：计算index，并对null做处理 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; // 步骤③：节点key存在，直接覆盖value if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 步骤④：判断该链为红黑树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 步骤⑤：该链为链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key,value,null); //链表长度大于8转换为红黑树进行处理 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // key已经存在直接覆盖value if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 步骤⑥：超过最大容量 就扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 3. 扩容机制扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。 我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。 12345678910111213void resize(int newCapacity) &#123; //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; &#125; Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值&#125; 这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。 1234567891011121314151617void transfer(Entry[] newTable) &#123; Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 &#125; while (e != null); &#125; &#125;&#125; newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。 下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。 下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。 元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： 因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图： 这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的resize上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\"，\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // 链表优化重hash的代码块 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 线程安全性在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)： 1234567891011121314151617181920public class HashMapInfiniteLoop &#123; private static HashMap&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(2, 0.75f); public static void main(String[] args) &#123; map.put(5, \"C\"); new Thread(\"Thread1\") &#123; public void run() &#123; map.put(7, \"B\"); System.out.println(map); &#125;; &#125;.start(); new Thread(\"Thread2\") &#123; public void run() &#123; map.put(3, \"A); System.out.println(map); &#125;; &#125;.start(); &#125; &#125; 其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。 通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。 注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。 线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。 e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。 于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。 JDK1.8与JDK1.7的性能对比HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。 鉴于JDK1.8做了多方面的优化，总体性能优于JDK1.7，下面我们从两个方面用例子证明这一点。 Hash较均匀的情况为了便于测试，我们先写一个类Key，如下： 123456789101112131415161718192021222324252627class Key implements Comparable&lt;Key&gt; &#123; private final int value; Key(int value) &#123; this.value = value; &#125; @Override public int compareTo(Key o) &#123; return Integer.compare(this.value, o.value); &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Key key = (Key) o; return value == key.value; &#125; @Override public int hashCode() &#123; return value; &#125;&#125; 这个类复写了equals方法，并且提供了相当好的hashCode函数，任何一个值的hashCode都不会相同，因为直接使用value当做hashcode。为了避免频繁的GC，我将不变的Key实例缓存了起来，而不是一遍一遍的创建它们。代码如下： 123456789101112131415public class Keys &#123; public static final int MAX_KEY = 10_000_000; private static final Key[] KEYS_CACHE = new Key[MAX_KEY]; static &#123; for (int i = 0; i &lt; MAX_KEY; ++i) &#123; KEYS_CACHE[i] = new Key(i); &#125; &#125; public static Key of(int value) &#123; return KEYS_CACHE[value]; &#125;&#125; 现在开始我们的试验，测试需要做的仅仅是，创建不同size的HashMap（1、10、100、……10000000），屏蔽了扩容的情况，代码如下： 1234567891011121314151617181920static void test(int mapSize) &#123; HashMap&lt;Key, Integer&gt; map = new HashMap&lt;Key,Integer&gt;(mapSize); for (int i = 0; i &lt; mapSize; ++i) &#123; map.put(Keys.of(i), i); &#125; long beginTime = System.nanoTime(); //获取纳秒 for (int i = 0; i &lt; mapSize; i++) &#123; map.get(Keys.of(i)); &#125; long endTime = System.nanoTime(); System.out.println(endTime - beginTime); &#125; public static void main(String[] args) &#123; for(int i=10;i&lt;= 1000 0000;i*= 10)&#123; test(i); &#125; &#125; 在测试中会查找不同的值，然后度量花费的时间，为了计算getKey的平均时间，我们遍历所有的get方法，计算总的时间，除以key的数量，计算一个平均值，主要用来比较，绝对值可能会受很多环境因素的影响。结果如下： 通过观测测试结果可知，JDK1.8的性能要高于JDK1.7 15%以上，在某些size的区域上，甚至高于100%。由于Hash算法较均匀，JDK1.8引入的红黑树效果不明显，下面我们看看Hash不均匀的的情况。 Hash极不均匀的情况假设我们又一个非常差的Key，它们所有的实例都返回相同的hashCode值。这是使用HashMap最坏的情况。代码修改如下： 123456789class Key implements Comparable&lt;Key&gt; &#123; //... @Override public int hashCode() &#123; return 1; &#125;&#125; 仍然执行main方法，得出的结果如下表所示： 从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。 测试环境：处理器为2.2 GHz Intel Core i7，内存为16 GB 1600 MHz DDR3，SSD硬盘，使用默认的JVM参数，运行在64位的OS X 10.10.1上。 小结(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。 (2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。 (3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。 (4) JDK1.8引入红黑树大程度优化了HashMap的性能。 (5) 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。 参考 JDK1.7&amp;JDK1.8 源码。 酷壳COOLSHELL，疫苗：JAVA HASHMAP的死循环，2013 CSDN博客频道，HashMap多线程死循环问题，2014。 红黑联盟，Java类集框架之HashMap(JDK1.8)源码剖析，2015。 CSDN博客频道， 教你初步了解红黑树，2010。 Java Code Geeks，HashMap performance improvements in Java 8，2014。 Importnew，危险！在HashMap中将可变对象用作Key，2014。 CSDN博客频道，为什么一般hashtable的桶数会取一个素数，2013。","categories":[{"name":"Java","slug":"Java","permalink":"https://kevinyangI.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://kevinyangI.github.io/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://kevinyangI.github.io/categories/Java/"}]}]}